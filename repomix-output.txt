This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.gitignore
app/api/characters/[id]/inventory/[inventoryId]/route.ts
app/api/characters/[id]/inventory/route.ts
app/api/characters/[id]/jobs/[jobId]/route.ts
app/api/characters/[id]/jobs/route.ts
app/api/characters/[id]/route.ts
app/api/characters/route.ts
app/api/chat/route.ts
app/api/drawings/route.ts
app/api/images/[id]/route.ts
app/api/images/route.ts
app/api/imgur-upload/route.ts
app/api/login/route.ts
app/api/logout/route.ts
app/api/public/images/[sceneId]/route.ts
app/api/public/scenes/route.ts
app/api/register/route.ts
app/api/scenes/route.ts
app/api/upload/route.ts
app/api/user/route.ts
app/components/BottomBar.tsx
app/components/character-popup/CharacterPopup.tsx
app/components/character-popup/EditableField.tsx
app/components/character-popup/FileUploader.tsx
app/components/character-popup/InventoryTab.tsx
app/components/character-popup/JobsTab.tsx
app/components/character-popup/StatsTab.tsx
app/components/CharacterList.tsx
app/components/DrawingLayer.tsx
app/components/DrawingToolbar.tsx
app/components/EncounterButton.tsx
app/components/ErrorBoundary.tsx
app/components/Home.tsx
app/components/ImageList.tsx
app/components/LoginForm.tsx
app/components/MainContent.tsx
app/components/RegisterForm.tsx
app/components/RightSideMenu.tsx
app/components/ui/button.tsx
app/components/ui/popover.tsx
app/globals.css
app/hooks/useCharacter.ts
app/hooks/useInventory.ts
app/hooks/useJobs.ts
app/layout.tsx
app/lib/db.ts
app/lib/prisma.ts
app/page.tsx
app/types/character.ts
app/types/image.ts
app/types/inventory.ts
app/types/layerImage.ts
app/types/user.ts
components.json
components/theme-provider.tsx
components/ui/accordion.tsx
components/ui/alert-dialog.tsx
components/ui/alert.tsx
components/ui/aspect-ratio.tsx
components/ui/avatar.tsx
components/ui/badge.tsx
components/ui/breadcrumb.tsx
components/ui/button.tsx
components/ui/calendar.tsx
components/ui/card.tsx
components/ui/carousel.tsx
components/ui/chart.tsx
components/ui/checkbox.tsx
components/ui/collapsible.tsx
components/ui/command.tsx
components/ui/context-menu.tsx
components/ui/dialog.tsx
components/ui/drawer.tsx
components/ui/dropdown-menu.tsx
components/ui/form.tsx
components/ui/hover-card.tsx
components/ui/input-otp.tsx
components/ui/input.tsx
components/ui/label.tsx
components/ui/menubar.tsx
components/ui/navigation-menu.tsx
components/ui/pagination.tsx
components/ui/popover.tsx
components/ui/progress.tsx
components/ui/radio-group.tsx
components/ui/resizable.tsx
components/ui/scroll-area.tsx
components/ui/select.tsx
components/ui/separator.tsx
components/ui/sheet.tsx
components/ui/sidebar.tsx
components/ui/skeleton.tsx
components/ui/slider.tsx
components/ui/sonner.tsx
components/ui/switch.tsx
components/ui/table.tsx
components/ui/tabs.tsx
components/ui/textarea.tsx
components/ui/toast.tsx
components/ui/toaster.tsx
components/ui/toggle-group.tsx
components/ui/toggle.tsx
components/ui/tooltip.tsx
components/ui/use-mobile.tsx
components/ui/use-toast.ts
hooks/use-mobile.tsx
hooks/use-toast.ts
lib/auth.ts
lib/session.ts
lib/utils.ts
next.config.mjs
package.json
postcss.config.mjs
prisma/schema.prisma
public/placeholder-logo.svg
public/placeholder.svg
styles/globals.css
tailwind.config.js
tsconfig.json
v0-user-next.config.js

================================================================
Files
================================================================

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules

# next.js
/.next/
/out/

# production
/build

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: app/api/characters/[id]/inventory/[inventoryId]/route.ts
================
import { NextResponse } from 'next/server';
import { createClient } from '@libsql/client';

const client = createClient({
  url: process.env.TURSO_DATABASE_URL || '',
  authToken: process.env.TURSO_AUTH_TOKEN || '',
});

export async function PUT(request: Request, { params }: { params: { id: string; inventoryId: string } }) {
  const characterId = parseInt(params.id);
  const inventoryId = parseInt(params.inventoryId);
  const { contents } = await request.json();
  try {
    const result = await client.execute({
      sql: 'UPDATE Inventory SET Contents = ? WHERE Inventoryid = ? AND CharacterId = ?',
      args: [JSON.stringify(contents), inventoryId, characterId],
    });
    if (result.rowsAffected === 0) {
      return NextResponse.json({ error: 'Inventory not found' }, { status: 404 });
    }
    const updatedInventory = await client.execute({
      sql: 'SELECT * FROM Inventory WHERE Inventoryid = ?',
      args: [inventoryId],
    });
    return NextResponse.json(updatedInventory.rows[0]);
  } catch (error) {
    console.error('Error updating inventory:', error);
    return NextResponse.json({ error: 'Failed to update inventory' }, { status: 500 });
  }
}

================
File: app/api/characters/[id]/inventory/route.ts
================
// app/inventory/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { createClient } from '@libsql/client';

// Define types for inventory data
interface InventoryItem {
  slot: number;
  name: string;
  description: string | null;
}

interface Inventory {
  Inventoryid: number;
  CharacterId: number;
  Contents: InventoryItem[];
}

// Initialize the libSQL client for Turso
const client = createClient({
  url: process.env.TURSO_DATABASE_URL || '',
  authToken: process.env.TURSO_AUTH_TOKEN || '',
});

export async function GET(req: NextRequest) {
  const { searchParams } = new URL(req.url);
  const characterId = searchParams.get('characterId');

  if (!characterId || isNaN(parseInt(characterId))) {
    return NextResponse.json({ error: 'Invalid character ID' }, { status: 400 });
  }

  const charId = parseInt(characterId);

  try {
    // Fetch the inventory for the character
    const result = await client.execute({
      sql: 'SELECT * FROM inventory WHERE character_id = ?',
      args: [charId],
    });

    let inventoryData: Inventory;
    if (result.rows.length === 0) {
      // Initialize the inventory with 16 empty slots
      const initialContents: InventoryItem[] = Array.from({ length: 16 }, (_, i) => ({
        slot: i + 1,
        name: '',
        description: null,
      }));
      await client.execute({
        sql: 'INSERT INTO inventory (character_id, contents) VALUES (?, ?)',
        args: [charId, JSON.stringify(initialContents)],
      });

      // Fetch the newly created inventory
      const newResult = await client.execute({
        sql: 'SELECT * FROM inventory WHERE character_id = ?',
        args: [charId],
      });
      inventoryData = {
        Inventoryid: newResult.rows[0].inventory_id as number,
        CharacterId: newResult.rows[0].character_id as number,
        Contents: JSON.parse(newResult.rows[0].contents as string) as InventoryItem[],
      };
    } else {
      inventoryData = {
        Inventoryid: result.rows[0].inventory_id as number,
        CharacterId: result.rows[0].character_id as number,
        Contents: JSON.parse(result.rows[0].contents as string) as InventoryItem[],
      };

      // Ensure the contents array has exactly 16 slots
      if (!Array.isArray(inventoryData.Contents) || inventoryData.Contents.length !== 16) {
        const allSlots = Array.from({ length: 16 }, (_, i) => i + 1);
        const newContents: InventoryItem[] = allSlots.map(slot => {
          const existingItem = inventoryData.Contents.find((item) => item.slot === slot);
          return existingItem || { slot, name: '', description: null };
        });
        await client.execute({
          sql: 'UPDATE inventory SET contents = ? WHERE character_id = ?',
          args: [JSON.stringify(newContents), charId],
        });
        inventoryData.Contents = newContents;
      }
    }

    // Sort by slot number
    inventoryData.Contents.sort((a, b) => a.slot - b.slot);
    return NextResponse.json(inventoryData);
  } catch (error) {
    console.error('Error fetching inventory:', error);
    return NextResponse.json({ error: 'Failed to fetch inventory' }, { status: 500 });
  }
}

export async function POST(req: NextRequest) {
  try {
    const body = await req.json();
    const { characterId, contents } = body;

    if (!characterId || !contents) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    // Check if inventory already exists
    const existing = await client.execute({
      sql: 'SELECT * FROM inventory WHERE character_id = ?',
      args: [characterId],
    });

    if (existing.rows.length > 0) {
      return NextResponse.json({ error: 'Inventory already exists for this character' }, { status: 400 });
    }

    await client.execute({
      sql: 'INSERT INTO inventory (character_id, contents) VALUES (?, ?)',
      args: [characterId, JSON.stringify(contents)],
    });

    const newResult = await client.execute({
      sql: 'SELECT * FROM inventory WHERE character_id = ?',
      args: [characterId],
    });

    const newInventory: Inventory = {
      Inventoryid: newResult.rows[0].inventory_id as number,
      CharacterId: newResult.rows[0].character_id as number,
      Contents: JSON.parse(newResult.rows[0].contents as string) as InventoryItem[],
    };

    return NextResponse.json(newInventory);
  } catch (error) {
    console.error('Error creating inventory:', error);
    return NextResponse.json({ error: 'Failed to create inventory' }, { status: 500 });
  }
}

export async function PUT(req: NextRequest) {
  try {
    const body = await req.json();
    const { inventoryId, contents } = body;

    if (!inventoryId || !contents) {
      return NextResponse.json({ error: 'Missing required fields' }, { status: 400 });
    }

    const existing = await client.execute({
      sql: 'SELECT * FROM inventory WHERE inventory_id = ?',
      args: [inventoryId],
    });

    if (existing.rows.length === 0) {
      return NextResponse.json({ error: 'Inventory not found' }, { status: 404 });
    }

    await client.execute({
      sql: 'UPDATE inventory SET contents = ? WHERE inventory_id = ?',
      args: [JSON.stringify(contents), inventoryId],
    });

    const updatedInventory = await client.execute({
      sql: 'SELECT * FROM inventory WHERE inventory_id = ?',
      args: [inventoryId],
    });
    const updatedData: Inventory = {
      Inventoryid: updatedInventory.rows[0].inventory_id as number,
      CharacterId: updatedInventory.rows[0].character_id as number,
      Contents: JSON.parse(updatedInventory.rows[0].contents as string) as InventoryItem[],
    };
    return NextResponse.json(updatedData);
  } catch (error) {
    console.error('Error updating inventory:', error);
    return NextResponse.json({ error: 'Failed to update inventory' }, { status: 500 });
  }
}

================
File: app/api/characters/[id]/jobs/[jobId]/route.ts
================
import { NextResponse } from 'next/server';
import { createClient } from '@libsql/client';
import { getUserFromCookie } from '@/lib/auth';

const client = createClient({
  url: process.env.TURSO_DATABASE_URL || '',
  authToken: process.env.TURSO_AUTH_TOKEN || '',
});

export async function PUT(
  request: Request,
  { params }: { params: { id: string; jobId: string } }
) {
  const user = await getUserFromCookie();
  if (!user) {
    return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
  }

  const characterId = parseInt(params.id);
  const jobId = parseInt(params.jobId);
  const { name, description, tier } = await request.json();

  try {
    const characterCheck = await client.execute({
      sql: 'SELECT UserId FROM Character WHERE CharacterId = ?',
      args: [characterId],
    });

    if (characterCheck.rows.length === 0) {
      return NextResponse.json({ error: 'Character not found' }, { status: 404 });
    }

    if (user.role !== 'DM' && characterCheck.rows[0].UserId !== user.id) {
      return NextResponse.json({ error: 'Not authorized to update this character' }, { status: 403 });
    }

    const result = await client.execute({
      sql: 'UPDATE Job SET Name = ?, Description = ?, Tier = ? WHERE JobId = ? AND CharacterId = ?',
      args: [name, description, tier, jobId, characterId],
    });

    if (result.rowsAffected === 0) {
      return NextResponse.json({ error: 'Job not found or not updated' }, { status: 404 });
    }

    const updatedJob = await client.execute({
      sql: 'SELECT * FROM Job WHERE JobId = ?',
      args: [jobId],
    });

    return NextResponse.json(updatedJob.rows[0]);
  } catch (error) {
    console.error('Error updating job:', error);
    return NextResponse.json(
      {
        error: 'Failed to update job',
        details: error instanceof Error ? error.message : 'Unknown error',
      },
      { status: 500 }
    );
  }
}

================
File: app/api/characters/[id]/jobs/route.ts
================
import { NextResponse } from 'next/server';
import { createClient } from '@libsql/client';
import { getUserFromCookie } from '@/lib/auth';

const client = createClient({
  url: process.env.TURSO_DATABASE_URL || '',
  authToken: process.env.TURSO_AUTH_TOKEN || '',
});

export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  const user = await getUserFromCookie();
  if (!user) {
    return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
  }

  const characterId = parseInt(params.id);

  try {
    const result = await client.execute({
      sql: 'SELECT * FROM Job WHERE CharacterId = ?',
      args: [characterId],
    });

    return NextResponse.json(result.rows);
  } catch (error) {
    console.error('Error fetching jobs:', error);
    return NextResponse.json(
      { error: 'Failed to fetch jobs', details: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}

export async function POST(
  request: Request,
  { params }: { params: { id: string } }
) {
  const user = await getUserFromCookie();
  if (!user) {
    return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
  }

  const characterId = parseInt(params.id);
  const { name, description, tier } = await request.json();

  try {
    const characterCheck = await client.execute({
      sql: 'SELECT UserId FROM Character WHERE CharacterId = ?',
      args: [characterId],
    });

    if (characterCheck.rows.length === 0 || characterCheck.rows[0].UserId !== user.id) {
      return NextResponse.json({ error: 'Character not found or not authorized' }, { status: 403 });
    }

    const result = await client.execute({
      sql: 'INSERT INTO Job (Name, Description, Tier, CharacterId) VALUES (?, ?, ?, ?)',
      args: [name, description, tier, characterId],
    });

    const newJob = await client.execute({
      sql: 'SELECT * FROM Job WHERE JobId = ?',
      args: [result.lastInsertRowid ?? (() => { throw new Error('lastInsertRowid is undefined'); })()],
    });

    return NextResponse.json(newJob.rows[0]);
  } catch (error) {
    console.error('Error creating job:', error);
    return NextResponse.json(
      { error: 'Failed to create job', details: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}

================
File: app/api/characters/[id]/route.ts
================
import { NextResponse } from 'next/server'
import { createClient } from '@libsql/client'

const client = createClient({
  url: 'libsql://machiovttdb-pbeeltje.aws-eu-west-1.turso.io',
  authToken: 'eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9.eyJhIjoicnciLCJpYXQiOjE3MzY0MTc0NDksImlkIjoiMzhhZDhmZDYtZmMwMy00M2NjLWFjZjktMWJiMTNiZDZiY2U0IiwicmlkIjoiMDU3M2UyZmYtZTg1MS00NDhlLThmNmItMzY5MTEwODZjOTZmIn0.NYSv79DSUMoo6MTDrjjrag2qL2YN_x7VvabUBnEqPUMXKafJkaJt5tyVDLIEuAEka1lg2dbU-7BlUIyCpU6OBw'
})

export async function PUT(request: Request, { params }: { params: { id: string } }) {
  const id = params.id
  const updatedCharacter = await request.json()
  console.log("Received character update:", updatedCharacter)
  console.log("Path value:", updatedCharacter.Path)

  if (!id) {
    return NextResponse.json({ error: 'Character ID is required' }, { status: 400 })
  }

  const allowedFields = ['Name', 'Description', 'Path', 'Age', 'Level', 'Guard', 'Armor', 'MaxGuard', 'Strength', 'MaxStrength', 'Dexternity', 'MaxDexternity', 'Mind', 'MaxMind', 'Charisma', 'MaxCharisma', 'Skill', 'MaxSkill', 'Mp', 'MaxMp', 'PortraitUrl', 'TokenUrl']
  const updateFields = Object.keys(updatedCharacter).filter(key => allowedFields.includes(key))
  console.log("Fields to update:", updateFields)

  try {
    const setClause = updateFields
      .map(key => `${key} = ?`)
      .join(', ')
    const values = updateFields.map(key => updatedCharacter[key])
    console.log("SQL update:", `UPDATE Character SET ${setClause} WHERE CharacterId = ?`)
    console.log("Values:", values)

    await client.execute({
      sql: `UPDATE Character SET ${setClause} WHERE CharacterId = ?`,
      args: [...values, id],
    })

    const updatedData = await client.execute({
      sql: 'SELECT * FROM Character WHERE CharacterId = ?',
      args: [id],
    })

    if (updatedData.rows.length === 0) {
      throw new Error('Character not found after update')
    }

    console.log("Updated character data:", updatedData.rows[0])
    return NextResponse.json(updatedData.rows[0])
  } catch (error) {
    console.error('Error updating character:', error)
    return NextResponse.json({ error: 'Failed to update character', details: error instanceof Error ? error.message : 'Unknown error' }, { status: 500 })
  }
}

export async function DELETE(request: Request, { params }: { params: { id: string } }) {
  const id = params.id

  try {
    await client.execute({
      sql: 'DELETE FROM Character WHERE CharacterId = ?',
      args: [id],
    })

    return NextResponse.json({ message: 'Character deleted successfully' })
  } catch (error) {
    console.error('Error deleting character:', error)
    return NextResponse.json({ error: 'Failed to delete character' }, { status: 500 })
  }
}

================
File: app/api/characters/route.ts
================
import { NextResponse } from "next/server"
import { createClient } from "@libsql/client"
import { getUserFromCookie } from "@/lib/auth"

const client = createClient({
  url: process.env.TURSO_DATABASE_URL || "",
  authToken: process.env.TURSO_AUTH_TOKEN || "",
})

export async function GET(req: Request) {
  console.log("Entering GET function in /api/characters/route.ts")

  if (!process.env.TURSO_DATABASE_URL || !process.env.TURSO_AUTH_TOKEN) {
    console.error("Database configuration is missing")
    return NextResponse.json({ error: "Server configuration error" }, { status: 500 })
  }

  const user = await getUserFromCookie()

  if (!user) {
    console.log("User is not authenticated")
    return NextResponse.json({ error: "Not authenticated" }, { status: 401 })
  }

  console.log("User authenticated:", user)

  try {
    console.log("Fetching all characters for the user")
    const result = await client.execute({
      sql: "SELECT * FROM Character WHERE UserId = ?",
      args: [user.id],
    })

    console.log("Characters fetched:", result.rows)
    return NextResponse.json(result.rows)
  } catch (error) {
    console.error("Error fetching characters:", error)
    return NextResponse.json(
      {
        error: "Failed to fetch characters",
        details: error instanceof Error ? error.message : "Unknown error",
      },
      { status: 500 },
    )
  }
}

export async function POST(req: Request) {
  console.log("Entering POST function in /api/characters/route.ts")

  if (!process.env.TURSO_DATABASE_URL || !process.env.TURSO_AUTH_TOKEN) {
    console.error("Database configuration is missing")
    return NextResponse.json({ error: "Server configuration error" }, { status: 500 })
  }

  const user = await getUserFromCookie()

  if (!user) {
    console.log("User is not authenticated")
    return NextResponse.json({ error: "Not authenticated" }, { status: 401 })
  }

  console.log("User authenticated:", user)

  try {
    const { category } = await req.json()
    console.log(`Attempting to add new character in category: ${category}`)

    if (!category) {
      return NextResponse.json({ error: "Category is required" }, { status: 400 })
    }

    console.log("Executing SQL insert")
    const result = await client.execute({
      sql: "INSERT INTO Character (Name, Description, Path, Category, UserId) VALUES (?, ?, ?, ?, ?)",
      args: [`New ${category}`, "Description placeholder", "Warrior", category, user.id],
    })

    console.log("SQL insert result:", result)

    if (!result.lastInsertRowid) {
      throw new Error("Failed to insert new character")
    }

    console.log("Fetching newly inserted character")
    const newCharacter = await client.execute({
      sql: "SELECT * FROM Character WHERE CharacterId = ?",
      args: [result.lastInsertRowid],
    })

    console.log("New character fetched:", newCharacter.rows[0])

    return NextResponse.json(newCharacter.rows[0])
  } catch (error) {
    console.error("Error adding character:", error)
    return NextResponse.json(
      { error: "Failed to add character", details: error instanceof Error ? error.message : "Unknown error" },
      { status: 500 },
    )
  }
}

================
File: app/api/chat/route.ts
================
import { NextResponse } from "next/server"
import { createClient } from "@libsql/client"
import { getUserFromCookie } from "@/lib/auth"

const client = createClient({
  url: process.env.TURSO_DATABASE_URL || "",
  authToken: process.env.TURSO_AUTH_TOKEN || "",
})

export async function GET(req: Request) {
  console.log("Entering GET /api/chat")

  if (!process.env.TURSO_DATABASE_URL || !process.env.TURSO_AUTH_TOKEN) {
    console.error("Database configuration missing")
    return NextResponse.json({ error: "Server configuration error" }, { status: 500 })
  }

  const user = await getUserFromCookie()
  if (!user) {
    console.log("User not authenticated")
    return NextResponse.json({ error: "Not authenticated" }, { status: 401 })
  }

  try {
    console.log("Fetching chat messages for user:", user.id)
    const result = await client.execute({
      sql: "SELECT * FROM ChatMessage WHERE UserId = ? ORDER BY Timestamp ASC",
      args: [user.id],
    })
    console.log("Chat messages fetched:", result.rows)
    return NextResponse.json(result.rows)
  } catch (error) {
    console.error("Error fetching chat messages:", error)
    return NextResponse.json(
      { error: "Failed to fetch chat messages", details: error instanceof Error ? error.message : "Unknown error" },
      { status: 500 }
    )
  }
}

export async function POST(req: Request) {
  console.log("Entering POST /api/chat")

  if (!process.env.TURSO_DATABASE_URL || !process.env.TURSO_AUTH_TOKEN) {
    console.error("Database configuration missing")
    return NextResponse.json({ error: "Server configuration error" }, { status: 500 })
  }

  const user = await getUserFromCookie()
  if (!user) {
    console.log("User not authenticated")
    return NextResponse.json({ error: "Not authenticated" }, { status: 401 })
  }

  try {
    const { type, content } = await req.json()
    if (!type || !content) {
      return NextResponse.json({ error: "Type and content are required" }, { status: 400 })
    }

    const timestamp = new Date().toISOString()
    const username = user.username

    console.log("Saving chat message:", { type, content, timestamp, username })
    const result = await client.execute({
      sql: "INSERT INTO ChatMessage (Type, Content, Timestamp, Username, UserId) VALUES (?, ?, ?, ?, ?)",
      args: [type, content, timestamp, username, user.id],
    })

    if (!result.lastInsertRowid) {
      throw new Error("Failed to insert chat message")
    }

    const newMessage = await client.execute({
      sql: "SELECT * FROM ChatMessage WHERE MessageId = ?",
      args: [result.lastInsertRowid],
    })

    console.log("New chat message saved:", newMessage.rows[0])
    return NextResponse.json(newMessage.rows[0])
  } catch (error) {
    console.error("Error saving chat message:", error)
    return NextResponse.json(
      { error: "Failed to save chat message", details: error instanceof Error ? error.message : "Unknown error" },
      { status: 500 }
    )
  }
}

================
File: app/api/drawings/route.ts
================
import { NextResponse } from 'next/server'
import { db } from '../../lib/db'

export async function GET(request: Request) {
  try {
    const { searchParams } = new URL(request.url)
    const sceneId = searchParams.get('sceneId')
    
    if (!sceneId) {
      return NextResponse.json({ error: 'Scene ID is required' }, { status: 400 })
    }

    const stmt = db.prepare('SELECT * FROM Drawing WHERE sceneId = ? ORDER BY createdAt ASC')
    const drawings = stmt.all([sceneId])
    return NextResponse.json(drawings)
  } catch (error) {
    console.error('Error fetching drawings:', error)
    return NextResponse.json({ error: 'Failed to fetch drawings' }, { status: 500 })
  }
}

export async function POST(request: Request) {
  try {
    const data = await request.json()
    const stmt = db.prepare(
      'INSERT INTO Drawing (id, path, color, createdBy, sceneId, createdAt) VALUES (?, ?, ?, ?, ?, ?)'
    )
    stmt.run(data.id, data.path, data.color, data.createdBy, data.sceneId, data.createdAt || new Date().toISOString())
    return NextResponse.json({ id: data.id })
  } catch (error) {
    console.error('Error creating drawing:', error)
    return NextResponse.json({ error: 'Failed to create drawing' }, { status: 500 })
  }
}

export async function DELETE(request: Request) {
  try {
    const { searchParams } = new URL(request.url)
    const id = searchParams.get('id')
    if (!id) {
      return NextResponse.json({ error: 'Drawing ID is required' }, { status: 400 })
    }

    const stmt = db.prepare('DELETE FROM Drawing WHERE id = ?')
    stmt.run(id)
    return NextResponse.json({ success: true })
  } catch (error) {
    console.error('Error deleting drawing:', error)
    return NextResponse.json({ error: 'Failed to delete drawing' }, { status: 500 })
  }
}

================
File: app/api/images/[id]/route.ts
================
import { NextResponse } from "next/server";
import { createClient } from "@libsql/client";
import { getUserFromCookie } from "@/lib/auth";

const client = createClient({
  url: process.env.TURSO_DATABASE_URL || "",
  authToken: process.env.TURSO_AUTH_TOKEN || "",
});

export async function PUT(req: Request, { params }: { params: { id: string } }) {
  const user = await getUserFromCookie();
  if (!user || user.role !== "DM") {
    return NextResponse.json({ error: "Not authorized" }, { status: 401 });
  }

  try {
    const { name } = await req.json();
    const result = await client.execute({
      sql: "UPDATE DMImage SET Name = ? WHERE Id = ? AND UserId = ?",
      args: [name, params.id, user.id],
    });
    
    if (result.rows.length === 0) {
      return NextResponse.json({ error: "Image not found" }, { status: 404 });
    }

    return NextResponse.json({ message: "Image renamed" });
  } catch (error) {
    console.error("Error renaming image:", error);
    return NextResponse.json({ error: "Failed to rename image" }, { status: 500 });
  }
}

export async function DELETE(req: Request, { params }: { params: { id: string } }) {
  const user = await getUserFromCookie();
  if (!user || user.role !== "DM") {
    return NextResponse.json({ error: "Not authorized" }, { status: 401 });
  }

  try {
    await client.execute({
      sql: "DELETE FROM DMImage WHERE Id = ? AND UserId = ?",
      args: [params.id, user.id],
    });
    return NextResponse.json({ message: "Image deleted" });
  } catch (error) {
    console.error("Error deleting image:", error);
    return NextResponse.json({ error: "Failed to delete image" }, { status: 500 });
  }
}

================
File: app/api/images/route.ts
================
import { NextResponse } from "next/server";
import { createClient } from "@libsql/client";
import { getUserFromCookie } from "@/lib/auth";

const IMGUR_CLIENT_ID = process.env.IMGUR_CLIENT_ID || "missing-client-id";

const client = createClient({
  url: process.env.TURSO_DATABASE_URL || "",
  authToken: process.env.TURSO_AUTH_TOKEN || "",
});

export async function GET(req: Request) {
  console.log("GET /api/images started");
  const user = await getUserFromCookie();
  if (!user || user.role !== "DM") {
    console.log("Unauthorized access attempt");
    return NextResponse.json({ error: "Not authorized" }, { status: 401 });
  }

  try {
    const result = await client.execute({
      sql: "SELECT * FROM DMImage WHERE UserId = ?",
      args: [user.id],
    });
    console.log("Images fetched:", result.rows);
    return NextResponse.json(result.rows);
  } catch (error) {
    console.error("Error fetching images:", error);
    return NextResponse.json({ error: "Failed to fetch images" }, { status: 500 });
  }
}

export async function POST(req: Request) {
  console.log("POST /api/images started");
  try {
    const user = await getUserFromCookie();
    console.log("User from cookie:", user);
    if (!user || user.role !== "DM") {
      console.log("Unauthorized access attempt");
      return NextResponse.json({ error: "Not authorized" }, { status: 401 });
    }

    console.log("Parsing form data");
    const formData = await req.formData();
    const file = formData.get("file") as File;
    const category = formData.get("category") as string;
    console.log("Form data parsed:", { file: file?.name, category });

    if (!file || !category) {
      console.log("Missing file or category");
      return NextResponse.json({ error: "File and category required" }, { status: 400 });
    }

    if (!IMGUR_CLIENT_ID || IMGUR_CLIENT_ID === "missing-client-id") {
      throw new Error("IMGUR_CLIENT_ID is not configured in environment variables");
    }

    // Upload to Imgur
    console.log("Uploading to Imgur with Client-ID:", IMGUR_CLIENT_ID);
    const imgurForm = new FormData();
    imgurForm.append("image", file);
    const imgurResponse = await fetch("https://api.imgur.com/3/image", {
      method: "POST",
      headers: { Authorization: `Client-ID ${IMGUR_CLIENT_ID}` },
      body: imgurForm,
    });

    console.log("Imgur response status:", imgurResponse.status);
    if (!imgurResponse.ok) {
      const errorText = await imgurResponse.text();
      console.error("Imgur API error:", imgurResponse.status, errorText);
      try {
        const errorData = JSON.parse(errorText);
        const errorMessage = errorData.data?.error || "Unknown Imgur error";
        return NextResponse.json({ error: errorMessage }, { status: imgurResponse.status });
      } catch (parseError) {
        return NextResponse.json({ error: "Imgur upload failed", details: errorText }, { status: imgurResponse.status });
      }
    }

    const { data } = await imgurResponse.json();
    console.log("Imgur upload success:", data);

    // Insert into database
    console.log("Inserting into database");
    const result = await client.execute({
      sql: "INSERT INTO DMImage (Name, Link, Category, UserId) VALUES (?, ?, ?, ?) RETURNING *",
      args: [file.name, data.link, category, user.id],
    });

    if (result.rows.length === 0) {
      console.error("No rows returned from insert");
      throw new Error("Failed to insert image into database");
    }

    console.log("Inserted image:", result.rows[0]);
    return NextResponse.json(result.rows[0]);
  } catch (error) {
    console.error("POST /api/images error:", error);
    return NextResponse.json(
      { error: "Internal server error", details: error instanceof Error ? error.message : "Unknown error" },
      { status: 500 }
    );
  }
}

================
File: app/api/imgur-upload/route.ts
================
import { NextResponse } from "next/server";

// Use environment variable with a fallback
const IMGUR_CLIENT_ID = process.env.IMGUR_CLIENT_ID || "missing-client-id";

export async function POST(request: Request) {
  console.log("POST /api/imgur-upload started");
  const formData = await request.formData();
  const file = formData.get("file") as File;

  if (!file) {
    console.log("No file provided");
    return NextResponse.json({ error: "No file provided" }, { status: 400 });
  }

  if (!IMGUR_CLIENT_ID || IMGUR_CLIENT_ID === "missing-client-id") {
    console.error("IMGUR_CLIENT_ID not configured");
    return NextResponse.json({ error: "Imgur Client ID not configured" }, { status: 500 });
  }

  const body = new FormData();
  body.append("image", file);

  try {
    console.log("Uploading to Imgur with Client-ID:", IMGUR_CLIENT_ID);
    const response = await fetch("https://api.imgur.com/3/image", {
      method: "POST",
      headers: {
        Authorization: `Client-ID ${IMGUR_CLIENT_ID}`,
      },
      body,
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error("Imgur upload error:", response.status, errorText);
      throw new Error(`Imgur API error: ${response.status} - ${errorText}`);
    }

    const data = await response.json();
    console.log("Imgur upload success:", data);
    return NextResponse.json({ url: data.data.link });
  } catch (error) {
    console.error("Error uploading to Imgur:", error);
    return NextResponse.json({
      error: "Failed to upload image",
      details: error instanceof Error ? error.message : "Unknown error",
    }, { status: 500 });
  }
}

================
File: app/api/login/route.ts
================
import { NextResponse } from "next/server"
import bcrypt from "bcryptjs"
import { createClient } from "@libsql/client"
import { setUserCookie } from "@/lib/auth"

const client = createClient({
  url: process.env.TURSO_DATABASE_URL || "",
  authToken: process.env.TURSO_AUTH_TOKEN || "",
})

export async function POST(req: Request) {
  if (!process.env.TURSO_DATABASE_URL || !process.env.TURSO_AUTH_TOKEN) {
    console.error("Database configuration is missing")
    return NextResponse.json({ error: "Server configuration error" }, { status: 500 })
  }

  try {
    const { username, password, isTestLogin = false } = await req.json()

    console.log("Received login request:", { username, isTestLogin })

    if (isTestLogin) {
      console.log("Handling test login")
      if (username === "DM_User" && password === "dm_password") {
        const userForCookie = {
          id: 0,
          username: "DM_User",
          role: "DM" as const,
        }
        console.log("Test login successful, setting cookie")
        try {
          await setUserCookie(userForCookie)
        } catch (cookieError) {
          console.error("Error setting user cookie:", cookieError)
          return NextResponse.json({ error: "Failed to set user cookie", details: cookieError }, { status: 500 })
        }
        return NextResponse.json({ message: "Logged in successfully", role: "DM" })
      } else {
        return NextResponse.json({ error: "Invalid test credentials" }, { status: 401 })
      }
    }

    const result = await client.execute({
      sql: "SELECT * FROM User WHERE Username = ?",
      args: [username],
    })

    if (result.rows.length === 0) {
      return NextResponse.json({ error: "Invalid credentials" }, { status: 401 })
    }

    const user = result.rows[0]
    const isMatch = await bcrypt.compare(password, user.Password)

    if (!isMatch) {
      return NextResponse.json({ error: "Invalid credentials" }, { status: 401 })
    }

    const userForCookie = {
      id: user.UserId,
      username: user.Username,
      role: user.Role || "player", // Default to "player" if Role is not set
    }

    console.log("Login successful, setting cookie")
    try {
      await setUserCookie(userForCookie)
    } catch (cookieError) {
      console.error("Error setting user cookie:", cookieError)
      return NextResponse.json({ error: "Failed to set user cookie", details: cookieError }, { status: 500 })
    }

    return NextResponse.json({ message: "Logged in successfully", role: userForCookie.role })
  } catch (error) {
    console.error("Login error:", error)
    console.error("Error details:", JSON.stringify(error, Object.getOwnPropertyNames(error)))
    return NextResponse.json(
      {
        error: "Login failed",
        details: error instanceof Error ? error.message : "Unknown error",
        stack: error instanceof Error ? error.stack : undefined,
      },
      { status: 500 },
    )
  }
}

================
File: app/api/logout/route.ts
================
import { NextResponse } from "next/server"
import { clearUserCookie } from "@/lib/auth"

export async function POST(req: Request) {
  const response = NextResponse.json({ message: "Logged out successfully" })
  clearUserCookie(response)
  return response
}

================
File: app/api/public/images/[sceneId]/route.ts
================
import { NextResponse } from "next/server";
import { createClient } from "@libsql/client";

const client = createClient({
  url: process.env.TURSO_DATABASE_URL || "",
  authToken: process.env.TURSO_AUTH_TOKEN || "",
});

export async function GET(req: Request, { params }: { params: { sceneId: string } }) {
  const { sceneId } = params;

  try {
    // Get the scene image
    const result = await client.execute({
      sql: "SELECT * FROM DMImage WHERE Id = ? AND Category = 'Scene'",
      args: [sceneId],
    });

    if (result.rows.length === 0) {
      return NextResponse.json({ error: "Scene not found" }, { status: 404 });
    }

    return NextResponse.json(result.rows);
  } catch (error) {
    console.error("Error fetching scene:", error);
    return NextResponse.json({ error: "Failed to fetch scene" }, { status: 500 });
  }
}

================
File: app/api/public/scenes/route.ts
================
import { NextResponse } from "next/server";
import { createClient } from "@libsql/client";

const client = createClient({
  url: process.env.TURSO_DATABASE_URL || "",
  authToken: process.env.TURSO_AUTH_TOKEN || "",
});

export async function GET(req: Request) {
  // Check if we're requesting a specific scene
  const segments = req.url.split('/');
  const lastSegment = segments[segments.length - 1];
  
  // If the last segment is 'scenes', return all scenes
  if (lastSegment === 'scenes') {
    try {
      const result = await client.execute({
        sql: "SELECT * FROM DMImage WHERE Category = 'Scene' AND SceneData IS NOT NULL",
        args: [], // Empty array for no arguments
      });
      return NextResponse.json(result.rows);
    } catch (error) {
      return NextResponse.json({ error: "Failed to fetch scenes" }, { status: 500 });
    }
  }

  // Otherwise, treat the last segment as a scene ID
  const sceneId = lastSegment;
  try {
    const result = await client.execute({
      sql: "SELECT * FROM DMImage WHERE Id = ? AND Category = 'Scene' AND SceneData IS NOT NULL",
      args: [sceneId],
    });

    if (result.rows.length === 0) {
      return NextResponse.json({ error: "Scene not found" }, { status: 404 });
    }

    return NextResponse.json(result.rows[0]);
  } catch (error) {
    return NextResponse.json({ error: "Failed to fetch scene" }, { status: 500 });
  }
}

================
File: app/api/register/route.ts
================
import { NextResponse } from "next/server"
import bcrypt from "bcryptjs"
import { createClient } from "@libsql/client"

const client = createClient({
  url: process.env.TURSO_DATABASE_URL as string,
  authToken: process.env.TURSO_AUTH_TOKEN as string,
})

export async function POST(req: Request) {
  console.log("Registration attempt received")
  const clonedReq = req.clone()
  console.log("Request body:", await clonedReq.json())
  try {
    const { username, password } = await req.json()

    if (!username || !password) {
      return NextResponse.json({ error: "Username and password are required" }, { status: 400 })
    }

    // Check if user already exists
    const existingUser = await client.execute({
      sql: "SELECT * FROM User WHERE Username = ?",
      args: [username],
    })

    if (existingUser.rows.length > 0) {
      return NextResponse.json({ error: "Username already exists" }, { status: 400 })
    }

    // Hash password
    const salt = await bcrypt.genSalt(10)
    const hashedPassword = await bcrypt.hash(password, salt)

    // Create new user
    const result = await client.execute({
      sql: "INSERT INTO User (Username, Password) VALUES (?, ?)",
      args: [username, hashedPassword],
    })

    if (!result.lastInsertRowid) {
      return NextResponse.json({ error: "Failed to create user" }, { status: 500 })
    }

    return NextResponse.json({ message: "User registered successfully" })
  } catch (error) {
    console.error("Registration error:", error)
    return NextResponse.json(
      {
        error: "Registration failed",
        details: error instanceof Error ? error.message : "Unknown error",
        stack: error instanceof Error ? error.stack : undefined,
      },
      { status: 500 },
    )
  }
}

================
File: app/api/scenes/route.ts
================
import { NextResponse } from "next/server";
import { createClient } from "@libsql/client";
import { getUserFromCookie } from "@/lib/auth";

const client = createClient({
  url: process.env.TURSO_DATABASE_URL || "",
  authToken: process.env.TURSO_AUTH_TOKEN || "",
});

export async function GET(req: Request) {
  const user = await getUserFromCookie();
  if (!user || user.role !== "DM") {
    return NextResponse.json({ error: "Not authorized" }, { status: 401 });
  }

  try {
    const result = await client.execute({
      sql: "SELECT * FROM DMImage WHERE UserId = ? AND Category = 'Scene' AND SceneData IS NOT NULL",
      args: [user.id],
    });
    return NextResponse.json(result.rows);
  } catch (error) {
    return NextResponse.json({ error: "Failed to fetch scenes" }, { status: 500 });
  }
}

export async function POST(req: Request) {
  const user = await getUserFromCookie();
  if (!user || user.role !== "DM") {
    return NextResponse.json({ error: "Not authorized" }, { status: 401 });
  }

  try {
    const { sceneId, sceneData } = await req.json();

    if (!sceneId || !sceneData) {
      return NextResponse.json({ error: "Scene ID and data are required" }, { status: 400 });
    }

    const result = await client.execute({
      sql: "UPDATE DMImage SET SceneData = ? WHERE Id = ? AND UserId = ? AND Category = 'Scene' RETURNING *",
      args: [JSON.stringify(sceneData), sceneId, user.id],
    });

    if (result.rows.length === 0) {
      return NextResponse.json({ error: "Scene not found" }, { status: 404 });
    }

    return NextResponse.json(result.rows[0]);
  } catch (error) {
    return NextResponse.json({ error: "Failed to save scene" }, { status: 500 });
  }
}

================
File: app/api/upload/route.ts
================
import { put } from '@vercel/blob';
import { NextResponse } from 'next/server';

export async function POST(request: Request): Promise<NextResponse> {
  const { searchParams } = new URL(request.url);
  const filename = searchParams.get('filename');

  if (!filename) {
    return NextResponse.json({ error: 'Filename is required' }, { status: 400 });
  }

  try {
    const formData = await request.formData();
    const file = formData.get('file') as File;

    if (!file) {
      return NextResponse.json({ error: 'File is required' }, { status: 400 });
    }

    const blob = await put(filename, file, {
      access: 'public',
    });

    return NextResponse.json(blob);
  } catch (error) {
    console.error('Error uploading file:', error);
    return NextResponse.json({ 
      error: 'Failed to upload file', 
      details: error instanceof Error ? error.message : 'Unknown error'
    }, { status: 500 });
  }
}

================
File: app/api/user/route.ts
================
import { getUserFromCookie } from '@/lib/auth'
import { NextResponse } from 'next/server'

export async function GET() {
  const user = getUserFromCookie();
  if (!user) {
    return NextResponse.json({ error: 'Not authenticated' }, { status: 401 });
  }
  return NextResponse.json(user);
}

================
File: app/components/BottomBar.tsx
================
"use client"

import { useState } from "react"
import { Button } from "@/components/ui/button"
import EncounterButton from "./EncounterButton"

interface BottomBarProps {
  onDiceRoll: (sides: number, result: number, numberOfDice: number, individualRolls: number[]) => void
  onPhaseChange: (phase: string, color: string) => void
}

export default function BottomBar({ onDiceRoll, onPhaseChange }: BottomBarProps) {
  const [numberOfDice, setNumberOfDice] = useState(1)

  const rollDice = (sides: number) => {
    let total = 0
    const individualRolls: number[] = []
    for (let i = 0; i < numberOfDice; i++) {
      const roll = Math.floor(Math.random() * sides) + 1
      individualRolls.push(roll)
      total += roll
    }
    onDiceRoll(sides, total, numberOfDice, individualRolls)
    setNumberOfDice(1) // Reset to 1 after rolling
  }

  return (
    <div className="bg-gray-200 p-2 flex justify-center space-x-2 items-center w-full" style={{ backgroundImage: 'url("images/bottombar.jpeg")', backgroundSize: 'auto 150%', backgroundRepeat: 'repeat-x' }}>
      <input
        type="number"
        min="1"
        value={numberOfDice}
        onChange={(e) => setNumberOfDice(Math.max(1, parseInt(e.target.value) || 1))}
        className="w-12 h-8 text-center border rounded bg-gray-400"
      />
      <Button onClick={() => rollDice(4)} variant="default" size="icon" className="bg-neutral-600 border-b-4 border-neutral-800">
        d4
      </Button>
      <Button onClick={() => rollDice(6)} variant="default" size="icon" className="bg-neutral-600 border-b-4 border-neutral-800">
        d6
      </Button>
      <Button onClick={() => rollDice(8)} variant="default" size="icon" className="bg-neutral-600 border-b-4 border-neutral-800">
        d8
      </Button>
      <Button onClick={() => rollDice(10)} variant="default"  size="icon" className="bg-neutral-600 border-b-4 border-neutral-800">
        d10
      </Button>
      <Button onClick={() => rollDice(12)} variant="default"  size="icon"className="bg-neutral-600 border-b-4 border-neutral-800">
        d12
      </Button>
      <Button onClick={() => rollDice(20)} variant="default"  size="icon" className="bg-neutral-600 border-b-4 border-neutral-800">
        d20
      </Button>
      <Button onClick={() => rollDice(30)} variant="default"  size="icon" className="bg-neutral-600 border-b-4 border-neutral-800">
        d30
      </Button>
      <Button onClick={() => rollDice(100)} variant="default" size="icon" className="bg-neutral-600 border-b-4 border-neutral-800">
        d100
      </Button>
      <EncounterButton onPhaseChange={onPhaseChange} />
    </div>
  )
}

================
File: app/components/character-popup/CharacterPopup.tsx
================
// components/character-popup/CharacterPopup.tsx
'use client'

import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { X } from 'lucide-react';
import { Character } from '../../types/character';
import { StatsTab } from './StatsTab';
import { JobsTab } from './JobsTab';
import { InventoryTab } from './InventoryTab';

interface CharacterPopupProps {
  character: Character;
  onClose: () => void;
  onUpdate: (updatedCharacter: Character) => void;
}

export default function CharacterPopup({ character, onClose, onUpdate }: CharacterPopupProps) {
  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-[100]" onClick={(e) => { if (e.target === e.currentTarget) onClose(); }}>
      <div className="bg-white p-6 rounded-lg w-full max-w-3xl max-h-[90vh] overflow-y-auto relative z-[101]" onClick={e => e.stopPropagation()} onMouseDown={e => e.stopPropagation()} onMouseUp={e => e.stopPropagation()}>
        <Button variant="ghost" size="icon" className="absolute top-2 right-2" onClick={onClose}><X className="h-4 w-4" /></Button>
        <Tabs defaultValue="stats" onClick={e => e.stopPropagation()} onMouseDown={e => e.stopPropagation()} onMouseUp={e => e.stopPropagation()}>
          <TabsList>
            <TabsTrigger value="stats">Stats</TabsTrigger>
            <TabsTrigger value="jobs">Jobs</TabsTrigger>
            <TabsTrigger value="inventory">Inventory</TabsTrigger>
          </TabsList>
          <TabsContent value="stats">
            <StatsTab character={character} onUpdate={onUpdate} onClose={onClose} />
          </TabsContent>
          <TabsContent value="jobs">
            <JobsTab characterId={character.CharacterId} />
          </TabsContent>
          <TabsContent value="inventory">
            <InventoryTab characterId={character.CharacterId} maxStrength={character.MaxStrength || 0} />
          </TabsContent>
        </Tabs>
      </div>
    </div>
  );
}

================
File: app/components/character-popup/EditableField.tsx
================
// components/character-popup/EditableField.tsx
import { useState, useEffect, useRef } from 'react';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import { Edit2 } from 'lucide-react';

interface EditableFieldProps {
  value: string;
  onChange: (value: string) => void;
  isTextarea?: boolean;
  className?: string;
}

export function EditableField({ value, onChange, isTextarea = false, className }: EditableFieldProps) {
  const [editing, setEditing] = useState(false);
  const [tempValue, setTempValue] = useState(value);
  const inputRef = useRef<HTMLInputElement | HTMLTextAreaElement>(null);

  useEffect(() => {
    if (editing && inputRef.current) {
      inputRef.current.focus();
    }
  }, [editing]);

  const handleSave = () => {
    onChange(tempValue);
    setEditing(false);
  };

  return (
    <div className="flex items-center">
      {editing ? (
        isTextarea ? (
          <Textarea
            ref={inputRef as React.RefObject<HTMLTextAreaElement>}
            value={tempValue}
            onChange={(e) => setTempValue(e.target.value)}
            onBlur={handleSave}
            className={`mt-1 w-full min-h-[150px] ${className}`}
          />
        ) : (
          <Input
            ref={inputRef as React.RefObject<HTMLInputElement>}
            value={tempValue}
            onChange={(e) => setTempValue(e.target.value)}
            onBlur={handleSave}
            className={`mt-1 w-full max-w-xs ${className}`}
          />
        )
      ) : (
        <>
          <span className={`mr-2 ${className}`}>{value}</span>
          <Button variant="ghost" size="sm" onClick={(e) => { e.stopPropagation(); setEditing(true); }}>
            <Edit2 className="h-4 w-4" />
          </Button>
        </>
      )}
    </div>
  );
}

================
File: app/components/character-popup/FileUploader.tsx
================
// components/character-popup/FileUploader.tsx
import { useState, useRef } from 'react';
import Image from 'next/image';
import { Button } from "@/components/ui/button";
import { toast } from "@/components/ui/use-toast";
import { Upload } from 'lucide-react';

interface FileUploaderProps {
  imageUrl: string | null;
  onUpload: (url: string) => void;
  label: string;
  width: number;
  height: number;
  isToken?: boolean;
}

export function FileUploader({ imageUrl, onUpload, label, width, height, isToken = false }: FileUploaderProps) {
  const [uploading, setUploading] = useState(false);
  const fileInputRef = useRef<HTMLInputElement>(null);

  const handleFileChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      if (file.size > 5 * 1024 * 1024) {
        toast({ title: "Error", description: "Image size exceeds 5MB.", variant: "destructive" });
        return;
      }
      setUploading(true);
      const formData = new FormData();
      formData.append('file', file);
      try {
        const response = await fetch('/api/imgur-upload', { method: 'POST', body: formData });
        if (!response.ok) throw new Error('Failed to upload image');
        const { url } = await response.json();
        onUpload(url);
        toast({ title: `${label} Uploaded`, description: `${label} uploaded successfully!` });
      } catch (error) {
        console.error(`Error uploading ${label.toLowerCase()}:`, error);
        toast({ title: "Error", description: `Failed to upload ${label.toLowerCase()}.`, variant: "destructive" });
      } finally {
        setUploading(false);
      }
    }
  };

  return (
    <div className="flex flex-col items-center">
      <div className={`w-${width} h-${height} bg-gray-200 rounded-lg overflow-hidden`}>
        {imageUrl ? (
          uploading ? (
            <div className="w-full h-full flex items-center justify-center text-gray-400">Uploading...</div>
          ) : (
            <Image src={imageUrl} alt={`${label} of character`} width={width * 4} height={height * 4} style={{ objectFit: isToken ? 'cover' : 'contain' }} />
          )
        ) : (
          <div className="w-full h-full flex items-center justify-center text-gray-400 text-xs">{`No ${label}`}</div>
        )}
      </div>
      <input type="file" accept="image/*" onChange={handleFileChange} className="hidden" ref={fileInputRef} />
      <Button type="button" variant="outline" size="sm" className="mt-2" onClick={() => fileInputRef.current?.click()} disabled={uploading}>
        {uploading ? 'Uploading...' : `Upload ${label}`} <Upload className="ml-2 h-4 w-4" />
      </Button>
    </div>
  );
}

================
File: app/components/character-popup/InventoryTab.tsx
================
// components/character-popup/InventoryTab.tsx
import { useInventory } from '../../hooks/useInventory';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Edit2, Trash2 } from 'lucide-react';

interface InventoryTabProps {
  characterId: number;
  maxStrength: number;
}

export function InventoryTab({ characterId, maxStrength }: InventoryTabProps) {
  const { inventory, editingSlot, inventoryForm, handleInventoryEdit, handleInventoryFormChange, handleInventorySubmit, handleClearSlot } = useInventory(characterId);

  const maxCarrySlots = Math.ceil((maxStrength || 0) / 2);
  const totalSlots = 16;
  const availableSlots = Math.min(maxCarrySlots, totalSlots - 4) + 4;
  const allSlots = Array.from({ length: 16 }, (_, i) => i + 1);

  return (
    <div className="min-h-[500px]">
      <div className="space-y-6">
        <div>
          <h3 className="text-lg font-semibold mb-2">Belt & Hand (Slots 1–4)</h3>
          <ul className="grid grid-cols-2 gap-4">
            {allSlots.slice(0, 4).map(slot => {
              const item = inventory?.Contents.find(item => item.slot === slot) || { slot, name: '', description: null };
              return (
                <li key={slot} className="border p-4 rounded-lg">
                  {editingSlot === slot ? (
                    <div className="space-y-2">
                      <div>
                        <Label htmlFor={`inv-name-${slot}`}>Name</Label>
                        <Input id={`inv-name-${slot}`} value={inventoryForm?.name || ''} onChange={(e) => handleInventoryFormChange('name', e.target.value)} className="w-full max-w-[200px]" autoFocus />
                      </div>
                      <div>
                        <Label htmlFor={`inv-slot-${slot}`}>Slot</Label>
                        <Input id={`inv-slot-${slot}`} type="number" value={slot} disabled className="w-16" />
                      </div>
                      <div>
                        <Label htmlFor={`inv-desc-${slot}`}>Description</Label>
                        <Textarea id={`inv-desc-${slot}`} value={inventoryForm?.description || ''} onChange={(e) => handleInventoryFormChange('description', e.target.value)} className="w-full max-w-[200px] min-h-[100px]" />
                      </div>
                      <div className="flex space-x-2">
                        <Button size="sm" onClick={() => handleInventorySubmit(slot)}>Save</Button>
                        <Button size="sm" variant="outline" onClick={() => { handleInventoryEdit(0); }}>Cancel</Button>
                      </div>
                    </div>
                  ) : (
                    <div className="flex justify-between items-start">
                      <div>
                        <span className="font-medium">Slot {slot}: {item.name || 'Empty'}</span>
                        <p className="text-sm text-muted-foreground mt-1">{item.description || 'No description'}</p>
                      </div>
                      <div className="flex space-x-2">
                        <Button variant="ghost" size="sm" onClick={() => handleInventoryEdit(slot)}><Edit2 className="h-4 w-4" /></Button>
                        {item.name && (
                          <Button variant="ghost" size="sm" onClick={() => handleClearSlot(slot)}><Trash2 className="h-4 w-4" /></Button>
                        )}
                      </div>
                    </div>
                  )}
                </li>
              );
            })}
          </ul>
        </div>
        <div>
          <h3 className="text-lg font-semibold mb-2">Pack (Slots 5–16)</h3>
          <ul className="grid grid-cols-2 gap-4">
            {allSlots.slice(4, 16).map(slot => {
              const item = inventory?.Contents.find(item => item.slot === slot) || { slot, name: '', description: null };
              const isOverCapacity = slot > availableSlots;
              return (
                <li key={slot} className={`border p-4 rounded-lg ${isOverCapacity ? 'bg-red-100' : ''}`}>
                  {editingSlot === slot ? (
                    <div className="space-y-2">
                      <div>
                        <Label htmlFor={`inv-name-${slot}`}>Name</Label>
                        <Input id={`inv-name-${slot}`} value={inventoryForm?.name || ''} onChange={(e) => handleInventoryFormChange('name', e.target.value)} className="w-full max-w-[200px]" autoFocus />
                      </div>
                      <div>
                        <Label htmlFor={`inv-slot-${slot}`}>Slot</Label>
                        <Input id={`inv-slot-${slot}`} type="number" value={slot} disabled className="w-16" />
                      </div>
                      <div>
                        <Label htmlFor={`inv-desc-${slot}`}>Description</Label>
                        <Textarea id={`inv-desc-${slot}`} value={inventoryForm?.description || ''} onChange={(e) => handleInventoryFormChange('description', e.target.value)} className="w-full max-w-[200px] min-h-[100px]" />
                      </div>
                      <div className="flex space-x-2">
                        <Button size="sm" onClick={() => handleInventorySubmit(slot)}>Save</Button>
                        <Button size="sm" variant="outline" onClick={() => { handleInventoryEdit(0); }}>Cancel</Button>
                      </div>
                    </div>
                  ) : (
                    <div className="flex justify-between items-start">
                      <div>
                        <span className="font-medium">Slot {slot}: {item.name || 'Empty'}</span>
                        <p className="text-sm text-muted-foreground mt-1">{item.description || 'No description'}</p>
                      </div>
                      <div className="flex space-x-2">
                        <Button variant="ghost" size="sm" onClick={() => handleInventoryEdit(slot)}><Edit2 className="h-4 w-4" /></Button>
                        {item.name && (
                          <Button variant="ghost" size="sm" onClick={() => handleClearSlot(slot)}><Trash2 className="h-4 w-4" /></Button>
                        )}
                      </div>
                    </div>
                  )}
                </li>
              );
            })}
          </ul>
        </div>
      </div>
    </div>
  );
}

================
File: app/components/character-popup/JobsTab.tsx
================
// components/character-popup/JobsTab.tsx
import { useJobs } from '../../hooks/useJobs';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Edit2 } from 'lucide-react';

interface JobsTabProps {
  characterId: number;
}

export function JobsTab({ characterId }: JobsTabProps) {
  const { jobs, newJobName, setNewJobName, editingJob, jobForm, handleAddJob, handleJobEdit, handleJobFormChange, handleJobSubmit } = useJobs(characterId);

  return (
    <div className="min-h-[500px]">
      <div className="space-y-4">
        {jobs.length > 0 ? (
          <ul className="space-y-4">
            {jobs.map((job) => (
              <li key={job.JobId} className="border p-4 rounded-lg">
                {editingJob === job.JobId ? (
                  <div className="space-y-2">
                    <div>
                      <Label htmlFor={`job-name-${job.JobId}`}>Name</Label>
                      <Input id={`job-name-${job.JobId}`} value={jobForm?.name || ''} onChange={(e) => handleJobFormChange('name', e.target.value)} className="w-full max-w-xs" autoFocus />
                    </div>
                    <div>
                      <Label htmlFor={`job-tier-${job.JobId}`}>Tier</Label>
                      <Input id={`job-tier-${job.JobId}`} type="number" value={jobForm?.tier || 0} onChange={(e) => handleJobFormChange('tier', e.target.value)} className="w-16" min={0} />
                    </div>
                    <div>
                      <Label htmlFor={`job-desc-${job.JobId}`}>Description</Label>
                      <Textarea id={`job-desc-${job.JobId}`} value={jobForm?.description || ''} onChange={(e) => handleJobFormChange('description', e.target.value)} className="w-full min-h-[100px]" />
                    </div>
                    <div className="flex space-x-2">
                      <Button size="sm" onClick={() => handleJobSubmit(job.JobId)}>Save</Button>
                      <Button size="sm" variant="outline" onClick={() => { handleJobEdit({ ...job, JobId: -1 }); }}>Cancel</Button>
                    </div>
                  </div>
                ) : (
                  <div className="flex justify-between items-start">
                    <div>
                      <span className="font-medium">{job.Name} (Tier {job.Tier})</span>
                      <p className="text-sm text-muted-foreground mt-1">{job.Description || 'No description provided'}</p>
                    </div>
                    <Button variant="ghost" size="sm" onClick={() => handleJobEdit(job)} className="ml-2"><Edit2 className="h-4 w-4" /></Button>
                  </div>
                )}
              </li>
            ))}
          </ul>
        ) : (
          <p>Jobless..</p>
        )}
        <form onSubmit={handleAddJob} className="mt-4">
          <div className="flex items-center space-x-2">
            <Input type="text" placeholder="New Job Name" value={newJobName} onChange={(e) => setNewJobName(e.target.value)} className="w-full max-w-xs" />
            <Button type="submit" size="sm">Add Job</Button>
          </div>
        </form>
      </div>
    </div>
  );
}

================
File: app/components/character-popup/StatsTab.tsx
================
// components/character-popup/StatsTab.tsx
import { Character } from '../../types/character';
import { useCharacter } from '../../hooks/useCharacter';
import { EditableField } from './EditableField';
import { FileUploader } from './FileUploader';
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";

interface StatsTabProps {
  character: Character;
  onUpdate: (updatedCharacter: Character) => void;
  onClose: () => void;
}

export function StatsTab({ character, onUpdate, onClose }: StatsTabProps) {
  const { editedCharacter, setEditedCharacter, handleInputChange, handleSubmit } = useCharacter(character, onUpdate);

  const renderField = (label: string, name: string, type: string = "text", maxField?: string) => (
    <div className="space-y-1">
      <Label htmlFor={name}>{label}</Label>
      <div className="flex items-center space-x-2">
        <Input
          id={name}
          name={name}
          type={type}
          value={editedCharacter[name as keyof Character] ?? ''}
          onChange={handleInputChange}
          className={type === "number" ? "w-16" : "w-full max-w-xs"}
          {...(type === "number" ? { min: 0, max: 99 } : {})}
        />
        {maxField && (
          <>
            <span>/</span>
            <Input
              id={maxField}
              name={maxField}
              type="number"
              value={editedCharacter[maxField as keyof Character] ?? ''}
              onChange={handleInputChange}
              className="w-16"
              min={0}
              max={99}
            />
          </>
        )}
      </div>
    </div>
  );

  const renderPathField = () => (
    <div className="space-y-1">
      <Label htmlFor="Path">Path</Label>
      <select
        id="Path"
        name="Path"
        value={editedCharacter.Path || "Warrior"}
        onChange={handleInputChange}
        className="w-full max-w-xs h-10 rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2"
      >
        <option value="Warrior">Warrior</option>
        <option value="Magic User">Magic User</option>
      </select>
    </div>
  );

  return (
    <div className="min-h-[500px]">
      <form onSubmit={handleSubmit} className="space-y-6">
        <div className="grid grid-cols-2 gap-6">
          <div className="space-y-6">
            <div>
              <Label htmlFor="Name">Name</Label>
              <EditableField
                value={editedCharacter.Name}
                onChange={(value) => setEditedCharacter(prev => ({ ...prev, Name: value }))}
              />
            </div>
            <div className="grid grid-cols-2 gap-4">
              {renderField("Level", "Level", "number")}
              {renderField("Age", "Age", "number")}
            </div>
            <div>
              <Label htmlFor="Description">Description</Label>
              <EditableField
                value={editedCharacter.Description || ''}
                onChange={(value) => setEditedCharacter(prev => ({ ...prev, Description: value }))}
                isTextarea
                className="min-h-[150px]"
              />
            </div>
          </div>
          <div className="space-y-6">
            <FileUploader
              imageUrl={editedCharacter.PortraitUrl ?? null}
              onUpload={(url) => setEditedCharacter(prev => ({ ...prev, PortraitUrl: url }))}
              label="Portrait"
              width={50}
              height={50}
            />
            <FileUploader
              imageUrl={editedCharacter.TokenUrl ?? null}
              onUpload={(url) => setEditedCharacter(prev => ({ ...prev, TokenUrl: url }))}
              label="Token"
              width={16}
              height={16}
              isToken
            />
          </div>
        </div>
        {renderPathField()}
        <div className="grid grid-cols-2 gap-4">
          {renderField("Guard", "Guard", "number", "MaxGuard")}
          {renderField("Armor", "Armor", "number")}
        </div>
        <div className="grid grid-cols-2 gap-4">
          {renderField("Strength", "Strength", "number", "MaxStrength")}
          {renderField("Dexterity", "Dexternity", "number", "MaxDexternity")}
          {renderField("Mind", "Mind", "number", "MaxMind")}
          {renderField("Charisma", "Charisma", "number", "MaxCharisma")}
          {editedCharacter.Path === "Warrior" && renderField("Skill", "Skill", "number", "MaxSkill")}
          {editedCharacter.Path === "Magic User" && renderField("MP", "Mp", "number", "MaxMp")}
        </div>
        <div className="flex justify-end space-x-2 pt-4 border-t">
          <Button type="button" variant="outline" onClick={onClose}>Cancel</Button>
          <Button type="submit">Save</Button>
        </div>
      </form>
    </div>
  );
}

================
File: app/components/CharacterList.tsx
================
"use client"

import { useState, useMemo, useCallback, memo } from "react"
import Image from "next/image"
import { Button } from "@/components/ui/button"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Plus, Trash2 } from "lucide-react"
import CharacterPopup from "./character-popup/CharacterPopup"
import type { Character } from "../types/character"

const CATEGORIES = ["Party", "NPC", "Monster"] as const

interface CharacterListProps {
  categories: string[]
  characters: Character[]
  onAddCharacter: (category: string) => void
  onUpdateCharacter: (updatedCharacter: Character) => void
  onDeleteCharacter: (character: Character) => void
  currentUser: number
  isDM: boolean
}

// Memoized character list item component
const CharacterListItem = memo(({ 
  character, 
  onDragStart, 
  onSelect, 
  onDelete,
  currentUser,
  isDM
}: { 
  character: Character
  onDragStart: (e: React.DragEvent<HTMLLIElement>, character: Character) => void
  onSelect: (character: Character) => void
  onDelete: (character: Character) => void
  currentUser: number
  isDM: boolean
}) => {
  const imageUrl = character.TokenUrl || character.PortraitUrl || "/placeholder.svg"
  const imageAlt = `${character.TokenUrl ? 'Token' : 'Portrait'} of ${character.Name}`
  const canDrag = isDM || (character.Category === "Party" && character.UserId === currentUser)

  return (
    <li
      className="flex items-center justify-between p-2 bg-white rounded-lg shadow"
      draggable={canDrag}
      onDragStart={(e) => canDrag && onDragStart(e, character)}
    >
      <div className="flex items-center space-x-3">
        <div className="w-12 h-12 bg-gray-200 rounded-full overflow-hidden">
          {(character.TokenUrl || character.PortraitUrl) ? (
            <Image
              src={imageUrl}
              alt={imageAlt}
              width={48}
              height={48}
              className="object-cover"
              priority={false}
            />
          ) : (
            <div className="w-full h-full flex items-center justify-center text-gray-400 text-xs">
              No Image
            </div>
          )}
        </div>
        <button className="text-left hover:underline" onClick={() => onSelect(character)}>
          {character.Name}
        </button>
      </div>
      <Button variant="ghost" size="icon" onClick={() => onDelete(character)}>
        <Trash2 className="h-4 w-4" />
      </Button>
    </li>
  )
})

CharacterListItem.displayName = "CharacterListItem"

export default function CharacterList({
  characters,
  onAddCharacter,
  onUpdateCharacter,
  onDeleteCharacter,
  currentUser,
  isDM
}: CharacterListProps) {
  const [selectedCharacter, setSelectedCharacter] = useState<Character | null>(null)
  const [activeCategory, setActiveCategory] = useState<string>("Party")

  const handleDeleteCharacter = useCallback((character: Character) => {
    if (window.confirm(`Are you sure you want to delete ${character.Name}?`)) {
      onDeleteCharacter(character)
    }
  }, [onDeleteCharacter])

  const handleDragStart = useCallback((e: React.DragEvent<HTMLLIElement>, character: Character) => {
    e.dataTransfer.setData("imageId", character.CharacterId.toString())
    e.dataTransfer.setData("category", "Token")
    e.dataTransfer.setData("url", character.TokenUrl || character.PortraitUrl || "/placeholder.png")
    e.dataTransfer.setData("characterId", character.CharacterId.toString())
    e.dataTransfer.setData("character", JSON.stringify({
      Name: character.Name,
      Path: character.Path,
      Guard: character.Guard ?? 0,
      MaxGuard: character.MaxGuard ?? 0,
      Strength: character.Strength ?? 0,
      MaxStrength: character.MaxStrength ?? 0,
      Mp: character.Mp ?? 0,
      MaxMp: character.MaxMp ?? 0
    }))
  }, [])

  const handleSelectCharacter = useCallback((character: Character) => {
    setSelectedCharacter(character)
  }, [])

  const handleUpdateCharacter = useCallback((updatedCharacter: Character) => {
    onUpdateCharacter(updatedCharacter)
    setSelectedCharacter(null)
  }, [onUpdateCharacter])

  // Memoize the filtered characters for each category
  const filteredCharactersByCategory = useMemo(() => {
    return CATEGORIES.reduce((acc, category) => {
      acc[category] = characters.filter(
        (character) => (character.Category || character.category)?.toLowerCase() === category.toLowerCase()
      )
      return acc
    }, {} as Record<string, Character[]>)
  }, [characters])

  return (
    <Tabs value={activeCategory} onValueChange={setActiveCategory}>
      <TabsList className="grid w-full grid-cols-3">
        {CATEGORIES.map((category) => (
          <TabsTrigger key={category} value={category}>
            {category}
          </TabsTrigger>
        ))}
      </TabsList>
      {CATEGORIES.map((category) => {
        const filteredCharacters = filteredCharactersByCategory[category]
        return (
          <TabsContent key={category} value={category}>
            <ScrollArea className="h-[calc(100vh-250px)] pr-4">
              <ul className="space-y-2">
                {filteredCharacters.map((character) => (
                  <CharacterListItem
                    key={character.CharacterId}
                    character={character}
                    onDragStart={handleDragStart}
                    onSelect={handleSelectCharacter}
                    onDelete={handleDeleteCharacter}
                    currentUser={currentUser}
                    isDM={isDM}
                  />
                ))}
                {filteredCharacters.length === 0 && (
                  <li className="p-2 text-gray-500">No characters in this category</li>
                )}
              </ul>
              <Button
                className="w-full mt-4"
                onClick={() => onAddCharacter(category)}
              >
                <Plus className="w-4 h-4 mr-2" /> Add {category}
              </Button>
            </ScrollArea>
          </TabsContent>
        )
      })}
      {selectedCharacter && (
        <CharacterPopup
          character={selectedCharacter}
          onClose={() => setSelectedCharacter(null)}
          onUpdate={handleUpdateCharacter}
        />
      )}
    </Tabs>
  )
}

================
File: app/components/DrawingLayer.tsx
================
import { useEffect, useRef, useState } from 'react';
import { cn } from "@/lib/utils";

interface DrawingLayerProps {
  isDrawingMode: boolean;
  currentColor: string;
  currentTool: 'brush' | 'cursor';
  drawings: DrawingObject[];
  onDrawingComplete: (drawing: DrawingObject) => void;
  onDrawingSelect: (drawing: DrawingObject | null) => void;
  onDrawingDelete: (drawing: DrawingObject) => void;
  selectedDrawing: DrawingObject | null;
}

export interface DrawingObject {
  id: string;
  path: string;
  color: string;
  createdBy: number;
  createdAt: string;
}

export default function DrawingLayer({
  isDrawingMode,
  currentColor,
  currentTool,
  drawings,
  onDrawingComplete,
  onDrawingSelect,
  onDrawingDelete,
  selectedDrawing
}: DrawingLayerProps) {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [isDrawing, setIsDrawing] = useState(false);
  const [currentPath, setCurrentPath] = useState<string>('');

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Set canvas size to match parent
    const resizeCanvas = () => {
      const parent = canvas.parentElement;
      if (!parent) return;
      canvas.width = parent.clientWidth;
      canvas.height = parent.clientHeight;
    };

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    return () => window.removeEventListener('resize', resizeCanvas);
  }, []);

  useEffect(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Redraw all drawings
    drawings.forEach(drawing => {
      const path = new Path2D(drawing.path);
      ctx.strokeStyle = drawing.color;
      ctx.lineWidth = 2;
      ctx.stroke(path);
    });
  }, [drawings]);

  const startDrawing = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDrawingMode || currentTool !== 'brush') return;

    const canvas = canvasRef.current;
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    setIsDrawing(true);
    setCurrentPath(`M ${x} ${y}`);
  };

  const draw = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (!isDrawing) return;

    const canvas = canvasRef.current;
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    setCurrentPath(prev => `${prev} L ${x} ${y}`);

    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawings.forEach(drawing => {
      const path = new Path2D(drawing.path);
      ctx.strokeStyle = drawing.color;
      ctx.lineWidth = 2;
      ctx.stroke(path);
    });

    const currentPathObj = new Path2D(currentPath);
    ctx.strokeStyle = currentColor;
    ctx.lineWidth = 2;
    ctx.stroke(currentPathObj);
  };

  const stopDrawing = () => {
    if (!isDrawing) return;

    setIsDrawing(false);
    if (currentPath) {
      onDrawingComplete({
        id: Date.now().toString(),
        path: currentPath,
        color: currentColor,
        createdBy: 0, // TODO: Get actual user ID
        createdAt: new Date().toISOString()
      });
      setCurrentPath('');
    }
  };

  const handleClick = (e: React.MouseEvent<HTMLCanvasElement>) => {
    if (currentTool !== 'cursor') return;

    const canvas = canvasRef.current;
    if (!canvas) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;

    // Check if click is on any drawing
    const clickedDrawing = drawings.find(drawing => {
      const path = new Path2D(drawing.path);
      const ctx = canvas.getContext('2d');
      if (!ctx) return false;
      return ctx.isPointInPath(path, x, y);
    });

    onDrawingSelect(clickedDrawing || null);
  };

  return (
    <canvas
      ref={canvasRef}
      className={cn(
        "absolute inset-0",
        currentTool === 'brush' ? "pointer-events-auto" : "pointer-events-none",
        currentTool === 'cursor' && "cursor-pointer"
      )}
      onMouseDown={startDrawing}
      onMouseMove={draw}
      onMouseUp={stopDrawing}
      onMouseLeave={stopDrawing}
      onClick={handleClick}
      style={{ zIndex: 15 }}
    />
  );
}

================
File: app/components/DrawingToolbar.tsx
================
import { useState } from 'react';
import { cn } from "@/lib/utils";
import { Brush, MousePointer, Palette, Grid } from 'lucide-react';
import { Button } from './ui/button';
import { Popover, PopoverContent, PopoverTrigger } from './ui/popover';

interface DrawingToolbarProps {
  currentTool: 'brush' | 'cursor';
  onToolChange: (tool: 'brush' | 'cursor') => void;
  currentColor: string;
  onColorChange: (color: string) => void;
  gridColor: string;
  onGridColorChange: (color: string) => void;
}

const COLORS = [
  '#000000', '#FF0000', '#00FF00', '#0000FF',
  '#FFFF00', '#FF00FF', '#00FFFF', '#FFFFFF'
];

const GRID_COLORS = [
  { name: 'White', value: 'white' },
  { name: 'Black', value: 'black' },
  { name: 'Red', value: 'red' },
  { name: 'Green', value: 'green' },
  { name: 'Gray', value: 'rgba(0,0,0,0.1)' },
  { name: 'Hidden', value: 'transparent' }
];

export default function DrawingToolbar({
  currentTool,
  onToolChange,
  currentColor,
  onColorChange,
  gridColor,
  onGridColorChange,
}: DrawingToolbarProps) {
  const [isColorPickerOpen, setIsColorPickerOpen] = useState(false);
  const [isGridColorPickerOpen, setIsGridColorPickerOpen] = useState(false);

  return (
    <div className="fixed left-2 top-12 flex flex-col gap-2 backdrop-blur p-2 rounded-lg shadow-md z-10 bg-stone-300/90">
      <Button
        variant="ghost"
        size="icon"
        className={cn(
          "w-10 h-10",
          currentTool === 'cursor' && "bg-gray-200"
        )}
        onClick={() => onToolChange('cursor')}
      >
        <MousePointer className="w-5 h-5" />
      </Button>

      <Button
        variant="ghost"
        size="icon"
        className={cn(
          "w-10 h-10",
          currentTool === 'brush' && "bg-gray-200"
        )}
        onClick={() => onToolChange('brush')}
      >
        <Brush className="w-5 h-5" />
      </Button>

      <Popover open={isColorPickerOpen} onOpenChange={setIsColorPickerOpen}>
        <PopoverTrigger asChild>
          <Button
            variant="ghost"
            size="icon"
            className="w-10 h-10"
          >
            <Palette className="w-5 h-5" />
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-48 p-2">
          <div className="grid grid-cols-4 gap-2">
            {COLORS.map((color) => (
              <button
                key={color}
                className={cn(
                  "w-8 h-8 rounded-full border-2",
                  currentColor === color && "border-black"
                )}
                style={{ backgroundColor: color }}
                onClick={() => {
                  onColorChange(color);
                  setIsColorPickerOpen(false);
                }}
              />
            ))}
          </div>
        </PopoverContent>
      </Popover>

      <Popover open={isGridColorPickerOpen} onOpenChange={setIsGridColorPickerOpen}>
        <PopoverTrigger asChild>
          <Button
            variant="ghost"
            size="icon"
            className="w-10 h-10"
          >
            <Grid className="w-5 h-5" />
          </Button>
        </PopoverTrigger>
        <PopoverContent className="w-48 p-2">
          <div className="grid grid-cols-2 gap-2">
            {GRID_COLORS.map((color) => (
              <button
                key={color.value}
                className={cn(
                  "w-full h-8 rounded border-2 text-xs",
                  gridColor === color.value && "border-black"
                )}
                style={{ backgroundColor: color.value }}
                onClick={() => {
                  onGridColorChange(color.value);
                  setIsGridColorPickerOpen(false);
                }}
              >
                {color.name}
              </button>
            ))}
          </div>
        </PopoverContent>
      </Popover>
    </div>
  );
}

================
File: app/components/EncounterButton.tsx
================
"use client"

import { useState } from "react"
import { Button } from "@/components/ui/button"
import { X } from "lucide-react"

interface EncounterButtonProps {
  onPhaseChange: (phase: string, color: string) => void;
}

export default function EncounterButton({ onPhaseChange }: EncounterButtonProps) {
  const [phase, setPhase] = useState("Encounter")
  const phases = [
    { name: "Prepare", color: "bg-blue-100" },
    { name: "Quick", color: "bg-yellow-100" },
    { name: "Act", color: "bg-red-100" },
    { name: "Release", color: "bg-purple-100" },
  ]

  const handleClick = () => {
    const currentIndex = phases.findIndex((p) => p.name === phase)
    const nextIndex = (currentIndex + 1) % phases.length
    const nextPhase = phases[nextIndex]
    setPhase(nextPhase.name)
    onPhaseChange(nextPhase.name + " phase", nextPhase.color)
  }

  const resetEncounter = () => {
    setPhase("Encounter")
    onPhaseChange("It's over", "bg-white")
  }

  // Determine text color based on phase
  const textColor = phase === "Encounter" ? "text-white" : "text-black"

  return (
    <div className="flex items-center">
      <Button
        onClick={handleClick}
        className={`w-24 ${phase !== "Encounter" ? phases.find((p) => p.name === phase)?.color : "bg-neutral-600 border-b-4 border-neutral-800"} ${textColor} hover:bg-black hover:text-white`}
      >
        {phase}
      </Button>
      {phase !== "Encounter" && (
        <Button onClick={resetEncounter} variant="default" size="icon" className="bg-neutral-600 border-b-4 border-neutral-800" >
          <X className="h-4 w-4" />
        </Button>
      )}
    </div>
  )
}

================
File: app/components/ErrorBoundary.tsx
================
"use client"

import React, { type ErrorInfo } from "react"
import { Button } from "@/components/ui/button"

interface ErrorBoundaryProps {
  children: React.ReactNode
}

interface ErrorBoundaryState {
  hasError: boolean
  error: Error | null
  errorInfo: ErrorInfo | null
}

class ErrorBoundary extends React.Component<ErrorBoundaryProps, ErrorBoundaryState> {
  constructor(props: ErrorBoundaryProps) {
    super(props)
    this.state = { hasError: false, error: null, errorInfo: null }
  }

  static getDerivedStateFromError(error: Error): ErrorBoundaryState {
    return { hasError: true, error, errorInfo: null }
  }

  componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error("Uncaught error:", error, errorInfo)
    this.setState({ errorInfo })
  }

  render() {
    if (this.state.hasError) {
      return (
        <div className="flex flex-col items-center justify-center min-h-screen bg-gray-100">
          <div className="bg-white p-8 rounded-lg shadow-md max-w-md w-full">
            <h1 className="text-2xl font-bold mb-4 text-red-600">Oops! Something went wrong.</h1>
            <p className="mb-4 text-gray-600">{this.state.error?.message || "An unexpected error occurred."}</p>
            {this.state.errorInfo && (
              <pre className="bg-gray-100 p-4 rounded mb-4 overflow-auto text-sm">
                {this.state.errorInfo.componentStack}
              </pre>
            )}
            <Button
              onClick={() => {
                this.setState({ hasError: false, error: null, errorInfo: null })
                window.location.reload()
              }}
            >
              Try again
            </Button>
          </div>
        </div>
      )
    }

    return this.props.children
  }
}

export default ErrorBoundary

================
File: app/components/Home.tsx
================
"use client"

import { useState, useEffect } from "react"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import LoginForm from "./LoginForm"
import RegisterForm from "./RegisterForm"
import MainContent from "./MainContent"
import RightSideMenu from "./RightSideMenu"
import BottomBar from "./BottomBar"
import { toast } from "@/components/ui/use-toast"
import { getUserFromCookie } from "@/lib/auth"
import type { User } from "../types/user"
import type { Character } from "../types/character"
import ErrorBoundary from "./ErrorBoundary"
import type { DMImage } from "../types/image"
import type { LayerImage } from "../types/layerImage"
import DrawingLayer, { DrawingObject } from './DrawingLayer'
import DrawingToolbar from './DrawingToolbar'

export type MessageType = "user" | "system"

export interface ChatMessage {
  MessageId?: number // Add from DB
  type: MessageType
  content: string
  timestamp: string
  username: string
  UserId?: number // Add from DB
}

export default function Home() {
  const [user, setUser] = useState<User | null>(null)
  const [messages, setMessages] = useState<ChatMessage[]>([])
  const [characters, setCharacters] = useState<Character[]>([])
  const [chatBackgroundColor, setChatBackgroundColor] = useState("bg-white")
  const [images, setImages] = useState<DMImage[]>([])
  const [backgroundImage, setBackgroundImage] = useState<string>("")
  const [middleLayerImages, setMiddleLayerImages] = useState<any[]>([])
  const [topLayerImages, setTopLayerImages] = useState<any[]>([])
  const [isLoading, setIsLoading] = useState(true)
  const [scenes, setScenes] = useState<DMImage[]>([])
  const [selectedScene, setSelectedScene] = useState<DMImage | null>(null)
  const [gridSize, setGridSize] = useState<number>(50)
  const [gridColor, setGridColor] = useState<string>("rgba(0,0,0,0.1)")
  const [isInitialized, setIsInitialized] = useState(false)
  const [currentTool, setCurrentTool] = useState<'brush' | 'cursor'>('cursor')
  const [currentColor, setCurrentColor] = useState('#000000')
  const [drawings, setDrawings] = useState<DrawingObject[]>([])
  const [selectedDrawing, setSelectedDrawing] = useState<DrawingObject | null>(null)
  const [sceneScale, setSceneScale] = useState<number>(1)
  const [zoomLevel, setZoomLevel] = useState(1)

  const findMostRecentScene = (scenes: DMImage[]): DMImage | null => {
    let mostRecentScene = null;
    let mostRecentDate = null;

    for (const scene of scenes) {
      if (!scene.SceneData) continue;
      try {
        const sceneData = JSON.parse(scene.SceneData);
        if (sceneData.savedAt && (!mostRecentDate || new Date(sceneData.savedAt) > new Date(mostRecentDate))) {
          mostRecentDate = sceneData.savedAt;
          mostRecentScene = scene;
        }
      } catch (error) {
        console.error("Error parsing scene data:", error);
      }
    }

    return mostRecentScene;
  }

  const fetchPublicScene = async (sceneId: string) => {
    try {
      console.log('Fetching scene data from:', `/api/public/scenes/${sceneId}`)
      const sceneResponse = await fetch(`/api/public/scenes/${sceneId}`)
      console.log('Scene response status:', sceneResponse.status)
      
      if (sceneResponse.ok) {
        const scene = await sceneResponse.json()
        console.log('Received scene data:', scene)
        
        // Get the minimum required images for the scene
        console.log('Fetching scene images from:', `/api/public/images/${sceneId}`)
        const imagesResponse = await fetch(`/api/public/images/${sceneId}`)
        console.log('Images response status:', imagesResponse.status)
        
        if (imagesResponse.ok) {
          const sceneImages = await imagesResponse.json()
          console.log('Received scene images:', sceneImages)
          setImages(sceneImages)
          await handleLoadScene(scene)
        }
      }
    } catch (error) {
      console.error("Error loading public scene:", error)
    }
  }

  useEffect(() => {
    const initializeApp = async () => {
      try {
        setIsLoading(true)
        
        // First, try to load scenes without authentication
        const scenesResponse = await fetch('/api/public/scenes')
        if (scenesResponse.ok) {
          const allScenes = await scenesResponse.json()
          const mostRecentScene = findMostRecentScene(allScenes)
          
          if (mostRecentScene) {
            await handleLoadScene(mostRecentScene)
          }
        }

        // Load existing drawings
        const drawingsResponse = await fetch('/api/drawings')
        if (drawingsResponse.ok) {
          const existingDrawings = await drawingsResponse.json()
          setDrawings(existingDrawings)
        }

        // Then check user authentication
        const userData = await getUserFromCookie()
        if (userData) {
          setUser(userData)
          await Promise.all([fetchCharacters(), fetchChatMessages(), fetchScenes()])
          
          // If user is DM, fetch all images
          if (userData.role === "DM") {
            await fetchImages()
          }
        }
      } catch (error) {
        console.error("Error initializing app:", error)
        toast({ title: "Error", description: "Failed to initialize application.", variant: "destructive" })
      } finally {
        setIsLoading(false)
        setIsInitialized(true)
      }
    }
    void initializeApp()
  }, [])

  const fetchCharacters = async () => {
    try {
      const response = await fetch(`/api/characters`, { credentials: "include" })
      if (response.status === 401) {
        setUser(null)
        toast({ title: "Authentication Error", description: "Please log in again.", variant: "destructive" })
        return
      }
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`)
      const data = await response.json()
      setCharacters(data)
    } catch (error) {
      console.error("Error fetching characters:", error)
      toast({ title: "Error", description: "Failed to fetch characters.", variant: "destructive" })
    }
  }

  const fetchChatMessages = async () => {
    try {
      const response = await fetch("/api/chat", { credentials: "include" })
      if (response.status === 401) {
        setUser(null)
        toast({ title: "Authentication Error", description: "Please log in again.", variant: "destructive" })
        return
      }
      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`)
      const data = await response.json()
      setMessages(data.map((msg: any) => ({
        MessageId: msg.MessageId,
        type: msg.Type as MessageType,
        content: msg.Content,
        timestamp: msg.Timestamp,
        username: msg.Username,
        UserId: msg.UserId,
      })))
    } catch (error) {
      console.error("Error fetching chat messages:", error)
      toast({ title: "Error", description: "Failed to fetch chat messages.", variant: "destructive" })
    }
  }

  const fetchScenes = async () => {
    const response = await fetch("/api/scenes", { credentials: "include" })
    if (response.ok) {
      const scenes = await response.json()
      setScenes(scenes)
    }
  }

  const handleLogin = async (username: string, role: string) => {
    setUser({ id: 0, username, role })
    await Promise.all([fetchCharacters(), fetchChatMessages()])
  }

  const handleLogout = () => {
    setUser(null)
    setCharacters([])
    setMessages([])
  }

  const addMessage = async (type: MessageType, content: string, username: string) => {
    // Create a temporary message with a temporary ID
    const tempMessage: ChatMessage = {
      MessageId: -Date.now(), // Temporary negative ID
      type,
      content,
      timestamp: new Date().toISOString(),
      username,
      UserId: user?.id
    }

    // Add the message to the UI immediately
    setMessages((prev) => [...prev, tempMessage])

    // Send to database asynchronously
    try {
      const response = await fetch("/api/chat", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ type, content }),
      })
      if (!response.ok) throw new Error("Failed to save message")
      const newMessage = await response.json()
      
      // Update the message with the real database ID
      setMessages((prev) => 
        prev.map((msg) => 
          msg.MessageId === tempMessage.MessageId 
            ? {
                MessageId: newMessage.MessageId,
                type: newMessage.Type,
                content: newMessage.Content,
                timestamp: newMessage.Timestamp,
                username: newMessage.Username,
                UserId: newMessage.UserId,
              }
            : msg
        )
      )
    } catch (error) {
      console.error("Error saving message:", error)
      // Remove the temporary message if saving failed
      setMessages((prev) => prev.filter((msg) => msg.MessageId !== tempMessage.MessageId))
      toast({ title: "Error", description: "Failed to save message.", variant: "destructive" })
    }
  }

  const handleDiceRoll = (sides: number, result: number, numberOfDice: number, individualRolls: number[]) => {
    const rollsText = numberOfDice > 1 ? ` (${individualRolls.join(", ")})` : ""
    addMessage("user", `${numberOfDice}d${sides}: <strong>${result}</strong>${rollsText}`, user?.username || "Unknown")
  }

  const handlePhaseChange = (phase: string, color: string) => {
    addMessage("system", `Phase changed to: ${phase}`, "System")
    setChatBackgroundColor(color)
  }

  const handleAddCharacter = async (category: string) => {
    try {
      const response = await fetch("/api/characters", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ category }),
      })
      if (!response.ok) throw new Error("Failed to add character")
      const newCharacter = await response.json()
      setCharacters((prevCharacters) => [...prevCharacters, newCharacter])
    } catch (error) {
      console.error("Error adding character:", error)
      toast({ title: "Error", description: "Failed to add character. Please try again.", variant: "destructive" })
    }
  }

  const handleUpdateCharacter = async (updatedCharacter: Character) => {
    try {
      const response = await fetch(`/api/characters/${updatedCharacter.CharacterId}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(updatedCharacter),
      })
      if (!response.ok) throw new Error("Failed to update character")
      setCharacters((prevCharacters) =>
        prevCharacters.map((char) => (char.CharacterId === updatedCharacter.CharacterId ? updatedCharacter : char))
      )
    } catch (error) {
      console.error("Error updating character:", error)
      toast({ title: "Error", description: "Failed to update character. Please try again.", variant: "destructive" })
    }
  }

  const handleDeleteCharacter = async (character: Character) => {
    try {
      const response = await fetch(`/api/characters/${character.CharacterId}`, { method: "DELETE" })
      if (!response.ok) throw new Error("Failed to delete character")
      setCharacters((prevCharacters) => prevCharacters.filter((char) => char.CharacterId !== character.CharacterId))
    } catch (error) {
      console.error("Error deleting character:", error)
      toast({ title: "Error", description: "Failed to delete character. Please try again.", variant: "destructive" })
    }
  }

  const fetchImages = async (sceneOnly: boolean = false) => {
    const url = sceneOnly ? "/api/images?sceneOnly=true" : "/api/images"
    const response = await fetch(url, { credentials: "include" })
    if (response.ok) setImages(await response.json())
  }

  const handleAddImage = async (category: string, file: File) => {
    const formData = new FormData()
    formData.append("file", file)
    formData.append("category", category)
    try {
      const response = await fetch("/api/images", { method: "POST", body: formData })
      if (!response.ok) {
        const errorData = await response.json()
        throw new Error(errorData.error || "Failed to add image")
      }
      const newImage = await response.json()
      setImages((prev) => [...prev, newImage])
      toast({ title: "Image Uploaded", description: `${file.name} added to ${category}.` })
    } catch (error) {
      console.error("Error adding image:", error)
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Failed to add image.",
        variant: "destructive",
      })
    }
  }

  const handleDeleteImage = async (image: DMImage) => {
    const response = await fetch(`/api/images/${image.Id}`, { method: "DELETE" })
    if (response.ok) setImages((prev) => prev.filter((i) => i.Id !== image.Id))
  }

  const handleRenameImage = async (image: DMImage, newName: string) => {
    try {
      const response = await fetch(`/api/images/${image.Id}`, {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ name: newName }),
      })
      if (!response.ok) throw new Error("Failed to rename image")
      const updatedImage = await response.json()
      setImages((prev) => prev.map((i) => (i.Id === image.Id ? updatedImage : i)))
    } catch (error) {
      console.error("Error renaming image:", error)
      throw error
    }
  }

  const handleSetBackground = async (url: string) => {
    setBackgroundImage(url)
    // Clear existing drawings when changing scenes
    setDrawings([])
    
    // Find the scene image
    const sceneImage = images.find(img => img.Link === url)
    if (sceneImage?.SceneData) {
      try {
        const sceneData = JSON.parse(sceneImage.SceneData)
        setGridSize(sceneData.gridSize || 50)
        setGridColor(sceneData.gridColor || "rgba(0,0,0,0.1)")
        setMiddleLayerImages(sceneData.elements?.middleLayer || [])
        setTopLayerImages(sceneData.elements?.topLayer || [])
        setSceneScale(sceneData.scale || 1)

        // Temporarily disable drawings API calls
        // const drawingsResponse = await fetch(`/api/drawings?sceneId=${sceneImage.Id}`)
        // if (drawingsResponse.ok) {
        //   const sceneDrawings = await drawingsResponse.json()
        //   setDrawings(sceneDrawings)
        // }

        toast({ title: "Success", description: "Scene loaded successfully." })
      } catch (error) {
        console.error("Error loading scene:", error)
        toast({ title: "Error", description: "Failed to load scene data.", variant: "destructive" })
        // Clear all layers if there's an error parsing scene data
        setMiddleLayerImages([])
        setTopLayerImages([])
      }
    } else {
      // Reset to defaults for a new scene or a scene with no data
      setGridSize(50)
      setGridColor("rgba(0,0,0,0.1)")
      // Explicitly clear all tokens and images
      setMiddleLayerImages([])
      setTopLayerImages([])
      setSceneScale(1)
      // Clear drawings for scenes with no scene data
      setDrawings([])
      
      // Notify the user that this is a new scene with no saved data
      toast({ 
        title: "New Scene", 
        description: "Loaded a scene with no saved data. All tokens and images have been cleared." 
      })
    }
  }

  const handleDropImage = (category: string, image: DMImage, x: number, y: number) => {
    const imageData: { id: string; url: string; x: number; y: number; width?: number; height?: number; characterId?: number; character?: any } = { 
      id: image.Id.toString(), 
      url: image.Link, 
      x, 
      y 
    }
    if (category === "Image") {
      imageData.width = 100
      imageData.height = 100
      setMiddleLayerImages((prev) => [...prev, imageData])
    } else if (category === "Token") {
      imageData.width = 50
      imageData.height = 50
      // Check if this is a character token
      const character = characters.find(c => c.TokenUrl === image.Link || c.PortraitUrl === image.Link)
      if (character) {
        imageData.characterId = character.CharacterId
        imageData.character = {
          Name: character.Name,
          Path: character.Path,
          Guard: character.Guard ?? 0,
          MaxGuard: character.MaxGuard ?? 0,
          Strength: character.Strength ?? 0,
          MaxStrength: character.MaxStrength ?? 0,
          Mp: character.Mp ?? 0,
          MaxMp: character.MaxMp ?? 0
        }
        // Update the image in the images state with character information
        setImages(prev => prev.map(img => 
          img.Id === image.Id ? {
            ...img,
            CharacterId: character.CharacterId,
            Character: {
              Name: character.Name,
              Path: character.Path,
              Guard: character.Guard ?? 0,
              MaxGuard: character.MaxGuard ?? 0,
              Strength: character.Strength ?? 0,
              MaxStrength: character.MaxStrength ?? 0,
              Mp: character.Mp ?? 0,
              MaxMp: character.MaxMp ?? 0
            }
          } as DMImage : img
        ))
      }
      setTopLayerImages((prev) => [...prev, imageData])
    }
  }

  const handleUpdateImages = (middleLayer: LayerImage[], topLayer: LayerImage[]) => {
    setMiddleLayerImages(middleLayer)
    setTopLayerImages(topLayer)

    // Update characters state if any character data has changed
    const updatedCharacters = characters.map(char => {
      const updatedToken = topLayer.find(img => img.characterId === char.CharacterId)
      if (updatedToken?.character) {
        return {
          ...char,
          ...updatedToken.character
        }
      }
      return char
    })

    // Only update if there are actual changes
    if (JSON.stringify(updatedCharacters) !== JSON.stringify(characters)) {
      setCharacters(updatedCharacters)
    }
  }

  const handleSaveScene = async () => {
    if (!backgroundImage) {
      toast({ title: "Error", description: "No background image selected.", variant: "destructive" })
      return
    }

    const sceneImage = images.find(img => img.Link === backgroundImage)
    if (!sceneImage) {
      toast({ title: "Error", description: "Background image not found.", variant: "destructive" })
      return
    }

    const sceneData = {
      savedAt: new Date().toISOString(),
      gridSize,
      gridColor,
      scale: sceneScale,
      elements: {
        middleLayer: middleLayerImages,
        topLayer: topLayerImages
      }
    }

    try {
      const response = await fetch("/api/scenes", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          sceneId: sceneImage.Id,
          sceneData
        })
      })

      if (!response.ok) {
        throw new Error("Failed to save scene")
      }

      // Update both scenes and images
      await fetchScenes()
      
      // Also update the images state to get the latest SceneData
      const imagesResponse = await fetch("/api/images", { credentials: "include" })
      if (imagesResponse.ok) {
        const updatedImages = await imagesResponse.json()
        setImages(updatedImages)
        console.log("Images updated after saving scene data")
      }
      
      toast({ title: "Success", description: "Scene saved successfully." })
    } catch (error) {
      console.error("Error saving scene:", error)
      toast({ title: "Error", description: "Failed to save scene.", variant: "destructive" })
    }
  }

  const handleLoadScene = async (scene: DMImage) => {
    if (!scene.SceneData) {
      toast({ title: "Error", description: "No scene data found.", variant: "destructive" })
      return
    }

    try {
      const sceneData = JSON.parse(scene.SceneData || "{}")
      setBackgroundImage(scene.Link)
      setGridSize(sceneData.gridSize || 50)
      setGridColor(sceneData.gridColor || "rgba(0,0,0,0.1)")
      setMiddleLayerImages(sceneData.elements?.middleLayer || [])
      setTopLayerImages(sceneData.elements?.topLayer || [])
      setSceneScale(sceneData.scale || 1)

      // Temporarily disable drawings API calls
      // const drawingsResponse = await fetch(`/api/drawings?sceneId=${scene.Id}`)
      // if (drawingsResponse.ok) {
      //   const sceneDrawings = await drawingsResponse.json()
      //   setDrawings(sceneDrawings)
      // }

      // Refresh the images state to ensure we have the latest data
      const imagesResponse = await fetch("/api/images", { credentials: "include" })
      if (imagesResponse.ok) {
        const updatedImages = await imagesResponse.json()
        setImages(updatedImages)
        console.log("Images updated after loading scene")
      }
      
      toast({ title: "Success", description: "Scene loaded successfully." })
    } catch (error) {
      console.error("Error loading scene:", error)
      toast({ title: "Error", description: "Failed to load scene.", variant: "destructive" })
    }
  }

  const handleDeleteSceneData = async (image: DMImage) => {
    try {
      const response = await fetch("/api/scenes", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          sceneId: image.Id,
          sceneData: null
        })
      })

      if (!response.ok) {
        throw new Error("Failed to delete scene data")
      }

      // Update the scenes state
      await fetchScenes()
      
      // Refresh the images state to ensure we have the latest data
      const imagesResponse = await fetch("/api/images", { credentials: "include" })
      if (imagesResponse.ok) {
        const updatedImages = await imagesResponse.json()
        setImages(updatedImages)
        console.log("Images updated after deleting scene data")
      } else {
        // Fallback to local state update if API call fails
        setImages(prev => prev.map(img => 
          img.Id === image.Id 
            ? { ...img, SceneData: undefined } 
            : img
        ))
      }

      toast({ title: "Success", description: "Scene data deleted successfully." })
    } catch (error) {
      console.error("Error deleting scene data:", error)
      toast({ title: "Error", description: "Failed to delete scene data.", variant: "destructive" })
    }
  }

  const handleDrawingComplete = async (drawing: DrawingObject) => {
    // Find current scene ID
    const sceneImage = images.find(img => img.Link === backgroundImage)
    if (!sceneImage) {
      toast({ 
        title: "Error", 
        description: "No scene is currently active.", 
        variant: "destructive" 
      })
      return
    }

    try {
      const response = await fetch('/api/drawings', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          ...drawing,
          createdBy: user?.id || 0,
          sceneId: sceneImage.Id
        })
      })

      if (response.ok) {
        const savedDrawing = await response.json()
        setDrawings(prev => [...prev, { ...drawing, id: savedDrawing.id }])
      } else {
        toast({ 
          title: "Error", 
          description: "Failed to save drawing.", 
          variant: "destructive" 
        })
      }
    } catch (error) {
      console.error('Error saving drawing:', error)
      toast({ 
        title: "Error", 
        description: "Failed to save drawing.", 
        variant: "destructive" 
      })
    }
  }

  const handleDrawingSelect = (drawing: DrawingObject | null) => {
    setSelectedDrawing(drawing);
  };

  const handleDrawingDelete = async (drawing: DrawingObject) => {
    try {
      const response = await fetch(`/api/drawings?id=${drawing.id}`, {
        method: 'DELETE'
      })

      if (response.ok) {
        setDrawings(prev => prev.filter(d => d.id !== drawing.id))
        setSelectedDrawing(null)
      } else {
        toast({ 
          title: "Error", 
          description: "Failed to delete drawing.", 
          variant: "destructive" 
        })
      }
    } catch (error) {
      console.error('Error deleting drawing:', error)
      toast({ 
        title: "Error", 
        description: "Failed to delete drawing.", 
        variant: "destructive" 
      })
    }
  }

  const handleUpdateSceneScale = async (image: DMImage, scale: number) => {
    if (!image.SceneData) {
      toast({ title: "Error", description: "No scene data found.", variant: "destructive" })
      return
    }

    try {
      // Parse existing scene data
      const sceneData = JSON.parse(image.SceneData)
      
      // Update the scale
      const updatedSceneData = {
        ...sceneData,
        scale: scale
      }

      // Save the updated scene data
      const response = await fetch("/api/scenes", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          sceneId: image.Id,
          sceneData: updatedSceneData
        })
      })

      if (!response.ok) {
        throw new Error("Failed to update scene scale")
      }

      // Update the image in the local state
      setImages(
        images.map(img => 
          img.Id === image.Id 
            ? { ...img, SceneData: JSON.stringify(updatedSceneData) } 
            : img
        )
      )

      // If this is the current background, update the scale
      if (image.Link === backgroundImage) {
        setSceneScale(scale)
      }
    } catch (error) {
      console.error("Error updating scene scale:", error)
      toast({ title: "Error", description: "Failed to update scene scale.", variant: "destructive" })
      throw error
    }
  }

  if (isLoading || !isInitialized) {
    return <div className="flex items-center justify-center min-h-screen">Loading...</div>
  }

  if (!user) {
    return (
      <div className="flex flex-col h-screen">
        <div className="flex-grow">
          <MainContent
            backgroundImage={backgroundImage}
            middleLayerImages={middleLayerImages}
            topLayerImages={topLayerImages}
            onUpdateImages={handleUpdateImages}
            gridSize={gridSize}
            gridColor={gridColor}
            onGridSizeChange={setGridSize}
            onGridColorChange={setGridColor}
            currentTool="cursor"
            onToolChange={() => {}}
            currentColor="#000000"
            onColorChange={() => {}}
            sceneScale={sceneScale}
            zoomLevel={zoomLevel}
            setZoomLevel={setZoomLevel}
          />
        </div>
        <div className="absolute top-4 right-4 z-50">
          <div className="bg-white/90 backdrop-blur p-8 rounded-lg shadow-md max-w-md">
            <Tabs defaultValue="login">
              <TabsList className="grid w-full grid-cols-2">
                <TabsTrigger value="login">Login</TabsTrigger>
                <TabsTrigger value="register">Register</TabsTrigger>
              </TabsList>
              <TabsContent value="login">
                <LoginForm onLogin={handleLogin} />
              </TabsContent>
              <TabsContent value="register">
                <RegisterForm onRegister={handleLogin} />
              </TabsContent>
            </Tabs>
          </div>
        </div>
      </div>
    )
  }

  return (
    <ErrorBoundary>
      <div className="flex flex-col h-screen">
        <div className="flex flex-grow overflow-hidden">
          <div className="flex-grow overflow-hidden">
            <MainContent
              backgroundImage={backgroundImage}
              middleLayerImages={middleLayerImages}
              topLayerImages={topLayerImages}
              onUpdateImages={handleUpdateImages}
              gridSize={gridSize}
              gridColor={gridColor}
              onGridSizeChange={setGridSize}
              onGridColorChange={setGridColor}
              currentTool={currentTool}
              onToolChange={setCurrentTool}
              currentColor={currentColor}
              onColorChange={setCurrentColor}
              sceneScale={sceneScale}
              zoomLevel={zoomLevel}
              setZoomLevel={setZoomLevel}
            />
          </div>
          <RightSideMenu
            messages={messages}
            addMessage={addMessage}
            user={user}
            chatBackgroundColor={chatBackgroundColor}
            characters={characters}
            onAddCharacter={handleAddCharacter}
            onUpdateCharacter={handleUpdateCharacter}
            onDeleteCharacter={handleDeleteCharacter}
            onLogout={handleLogout}
            images={images}
            onAddImage={handleAddImage}
            onDeleteImage={handleDeleteImage}
            onRenameImage={handleRenameImage}
            onSetBackground={handleSetBackground}
            onDropImage={handleDropImage}
            scenes={scenes}
            onSaveScene={handleSaveScene}
            onLoadScene={handleLoadScene}
            onDeleteSceneData={handleDeleteSceneData}
            onUpdateSceneScale={handleUpdateSceneScale}
            setImages={setImages}
          />
        </div>
        <BottomBar onDiceRoll={handleDiceRoll} onPhaseChange={handlePhaseChange} />
      </div>
      <div className="relative w-full h-full">
        <DrawingLayer
          isDrawingMode={currentTool === 'brush'}
          currentColor={currentColor}
          currentTool={currentTool}
          drawings={drawings}
          onDrawingComplete={handleDrawingComplete}
          onDrawingSelect={handleDrawingSelect}
          onDrawingDelete={handleDrawingDelete}
          selectedDrawing={selectedDrawing}
        />
      </div>
    </ErrorBoundary>
  )
}

================
File: app/components/ImageList.tsx
================
"use client"

import { useState } from "react"
import Image from "next/image"
import { Button } from "@/components/ui/button"
import { ScrollArea } from "@/components/ui/scroll-area"
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs"
import { Plus, Trash2, Pencil } from "lucide-react"
import { toast } from "@/components/ui/use-toast"
import type { DMImage } from "../types/image"
import type { Character } from "../types/character"
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog"
import { Input } from "@/components/ui/input"
import { Label } from "@/components/ui/label"

interface ImageListProps {
  images: DMImage[]
  categories: string[]
  onAddImage: (category: string, file: File) => Promise<void>
  onDeleteImage: (image: DMImage) => Promise<void>
  onDragStart?: (e: React.DragEvent<HTMLLIElement>, image: DMImage) => void
  onSceneClick?: (url: string) => void
  onDeleteSceneData?: (image: DMImage) => Promise<void>
  onRenameImage?: (image: DMImage, newName: string) => Promise<void>
  onUpdateSceneScale?: (image: DMImage, scale: number) => Promise<void>
  characters?: Character[]
}

export default function ImageList({
  images,
  onAddImage,
  onDeleteImage,
  onDragStart,
  onSceneClick,
  onDeleteSceneData,
  onRenameImage,
  onUpdateSceneScale,
  characters = [],
}: ImageListProps) {
  const [activeCategory, setActiveCategory] = useState<string>("Scene")
  const [uploading, setUploading] = useState(false)
  const [selectedImage, setSelectedImage] = useState<DMImage | null>(null)
  const categories = ["Scene", "Image", "Token"]
  const [editDialogOpen, setEditDialogOpen] = useState(false)
  const [editingImage, setEditingImage] = useState<DMImage | null>(null)
  const [newName, setNewName] = useState("")
  const [sceneScale, setSceneScale] = useState(1)

  const handleDeleteImage = (image: DMImage) => {
    if (window.confirm(`Are you sure you want to delete ${image.Name}?`)) {
      onDeleteImage(image)
    }
  }

  const handleImageClick = (image: DMImage) => {
    if (image.Category === "Scene") {
      onSceneClick?.(image.Link);
    } else {
      const newSelectedImage = selectedImage?.Id === image.Id ? null : image;
      setSelectedImage(newSelectedImage);
    }
  }

  const handleUpload = async (category: string) => {
    const input = document.createElement("input");
    input.type = "file";
    input.accept = "image/*";
    input.onchange = async (e) => {
      const file = (e.target as HTMLInputElement).files?.[0];
      if (file) {
        if (file.size > 5 * 1024 * 1024) {
          toast({
            title: "Error",
            description: "Image size exceeds 5MB limit.",
            variant: "destructive",
          });
          return;
        }
        setUploading(true);
        try {
          await onAddImage(category, file);
          toast({
            title: "Image Uploaded",
            description: `${file.name} added to ${category}.`,
          });
        } catch (error) {
          toast({
            title: "Error",
            description: error instanceof Error ? error.message : "Failed to upload image.",
            variant: "destructive",
          });
        } finally {
          setUploading(false);
        }
      }
    };
    input.click();
  };

  const handleRenameImage = async (image: DMImage) => {
    if (image.Category === "Scene") {
      // For scenes, open the edit dialog with both name and scale options
      setEditingImage(image)
      setNewName(image.Name)
      
      // Get scale from scene data if it exists
      if (image.SceneData) {
        try {
          const sceneData = JSON.parse(image.SceneData)
          setSceneScale(sceneData.scale || 1)
        } catch (error) {
          setSceneScale(1)
        }
      } else {
        setSceneScale(1)
      }
      
      setEditDialogOpen(true)
    } else {
      // For other image types, just prompt for name
      const newName = window.prompt("Enter new name:", image.Name)
      if (newName && newName !== image.Name && onRenameImage) {
        try {
          await onRenameImage(image, newName)
          toast({
            title: "Success",
            description: "Image renamed successfully.",
          })
        } catch (error) {
          toast({
            title: "Error",
            description: "Failed to rename image.",
            variant: "destructive",
          })
        }
      }
    }
  }

  const handleSaveSceneEdit = async () => {
    if (!editingImage || !newName) return
    
    try {
      // First rename the image
      if (newName !== editingImage.Name && onRenameImage) {
        await onRenameImage(editingImage, newName)
      }
      
      // Then update the scale if the function is provided
      if (onUpdateSceneScale) {
        await onUpdateSceneScale(editingImage, sceneScale)
      }
      
      toast({
        title: "Success",
        description: "Scene updated successfully.",
      })
    } catch (error) {
      toast({
        title: "Error",
        description: "Failed to update scene.",
        variant: "destructive",
      })
    } finally {
      setEditDialogOpen(false)
      setEditingImage(null)
    }
  }

  const getNameClass = (name: string) => {
    // Default Tailwind text size is text-base (16px), reduce to text-sm (14px) if long
    return name.length > 10 ? "text-sm break-words" : "text-base"
  };

  return (
    <>
      <Tabs value={activeCategory} onValueChange={setActiveCategory}>
        <TabsList className="grid w-full grid-cols-3">
          {categories.map((category) => (
            <TabsTrigger key={category} value={category}>
              {category}
            </TabsTrigger>
          ))}
        </TabsList>
        {categories.map((category) => (
          <TabsContent key={category} value={category}>
            <ScrollArea className="h-[calc(100vh-250px)]">
              <Button
                variant="outline"
                size="sm"
                className="mt-4"
                onClick={() => handleUpload(category)}
                disabled={uploading}
              >
                {uploading ? (
                  "Uploading..."
                ) : (
                  <>
                    <Plus className="w-4 h-4 mr-2" /> Add {category}
                  </>
                )}
              </Button>
              <ul className="space-y-2 mt-4">
                {images
                  .filter((img) => img.Category === category)
                  .map((image) => (
                    <li
                      key={image.Id}
                      className="flex items-center gap-2 p-2 bg-white rounded-lg shadow hover:bg-gray-50 cursor-pointer relative"
                      draggable={image.Category !== "Scene"}
                      onDragStart={image.Category !== "Scene" ? (e) => onDragStart?.(e, image) : undefined}
                      onClick={() => handleImageClick(image)}
                      style={{ maxWidth: '100%' }}
                    >
                      <div className="flex-shrink-0 mr-2">
                        <Image
                          src={image.Link || "/placeholder.svg"}
                          alt={image.Name}
                          width={40}
                          height={40}
                          className="rounded object-cover"
                          style={{ objectFit: 'cover' }}
                        />
                      </div>
                      <div className="flex-1 min-w-0 max-w-[calc(100%-120px)]">
                        {image.Category !== "Scene" && (
                          <span className={`truncate block ${getNameClass(image.Name)}`}>
                            {image.Name}
                          </span>
                        )}
                        {image.Category === "Scene" && (
                          <span className="text-xs text-gray-600 truncate block">{image.Name}</span>
                        )}
                        {selectedImage?.Id === image.Id && image.Category === "Token" && image.Character && (
                          <span className="text-xs text-gray-600 truncate block">{image.Character.Name}</span>
                        )}
                      </div>
                      
                      <div className="flex gap-1 flex-shrink-0 ml-auto" style={{ minWidth: '80px' }}>
                        {image.Category === "Scene" && image.SceneData && (
                          <Button
                            variant="ghost"
                            size="icon"
                            onClick={(e) => {
                              e.stopPropagation();
                              if (window.confirm("Are you sure you want to clear this scene's data?")) {
                                onDeleteSceneData?.(image);
                              }
                            }}
                            className="text-blue-500 hover:text-blue-700 h-7 w-7"
                            title="Clear Scene Data"
                          >
                            <Trash2 className="h-3 w-3" />
                          </Button>
                        )}
                        <Button
                          variant="ghost"
                          size="icon"
                          onClick={(e) => {
                            e.stopPropagation();
                            handleRenameImage(image);
                          }}
                          title="Rename"
                          className="h-7 w-7"
                        >
                          <Pencil className="h-3 w-3" />
                        </Button>
                        <Button
                          variant="ghost"
                          size="icon"
                          onClick={(e) => {
                            e.stopPropagation();
                            handleDeleteImage(image);
                          }}
                          title="Delete Image"
                          className="text-gray-700 hover:text-gray-900 h-7 w-7"
                        >
                          <Trash2 className="h-3 w-3" />
                        </Button>
                      </div>
                    </li>
                  ))}
              </ul>
            </ScrollArea>
          </TabsContent>
        ))}
      </Tabs>

      <Dialog open={editDialogOpen} onOpenChange={setEditDialogOpen}>
        <DialogContent className="sm:max-w-[425px]">
          <DialogHeader>
            <DialogTitle>Edit Scene</DialogTitle>
          </DialogHeader>
          <div className="grid gap-4 py-4">
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="name" className="text-right">
                Name
              </Label>
              <Input
                id="name"
                value={newName}
                onChange={(e) => setNewName(e.target.value)}
                className="col-span-3"
              />
            </div>
            <div className="grid grid-cols-4 items-center gap-4">
              <Label htmlFor="scale" className="text-right">
                Scale
              </Label>
              <Input
                id="scale"
                type="number"
                min="0.1"
                step="0.1"
                value={sceneScale}
                onChange={(e) => setSceneScale(parseFloat(e.target.value) || 1)}
                className="col-span-3"
              />
            </div>
          </div>
          <DialogFooter>
            <Button onClick={handleSaveSceneEdit}>Save changes</Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  )
}

================
File: app/components/LoginForm.tsx
================
"use client"

import { useState } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { toast } from "@/components/ui/use-toast"
import { loginUser, loginDM } from "@/lib/auth"

interface LoginFormProps {
  onLogin: (username: string, role: string) => void
}

export default function LoginForm({ onLogin }: LoginFormProps) {
  const [username, setUsername] = useState("")
  const [password, setPassword] = useState("")
  const [isLoading, setIsLoading] = useState(false)

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)

    try {
      const result = await loginUser(username, password)
      if (result.success) {
        onLogin(username, result.role)
        toast({
          title: "Login Successful",
          description: `Welcome back, ${username}! You are logged in as a ${result.role}.`,
        })
      } else {
        throw new Error(result.error || "Login failed")
      }
    } catch (error) {
      console.error("Login error:", error)
      toast({
        title: "Login Failed",
        description: error instanceof Error ? error.message : "An unexpected error occurred during login",
        variant: "destructive",
      })
    } finally {
      setIsLoading(false)
    }
  }

  const handleDMLogin = async (e: React.MouseEvent) => {
    e.preventDefault()
    setIsLoading(true)
    try {
      const result = await loginDM()
      if (result.success) {
        onLogin("DM_User", "DM")
        toast({
          title: "DM Login",
          description: "Logged in as DM for testing.",
        })
      } else {
        throw new Error(result.error || "DM Login failed")
      }
    } catch (error) {
      console.error("DM Login error:", error)
      toast({
        title: "DM Login Failed",
        description: error instanceof Error ? error.message : "An error occurred during DM login",
        variant: "destructive",
      })
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <Input
        type="text"
        placeholder="Username"
        value={username}
        onChange={(e) => setUsername(e.target.value)}
        required
      />
      <Input
        type="password"
        placeholder="Password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        required
      />
      <Button type="submit" className="w-full" disabled={isLoading}>
        {isLoading ? "Logging in..." : "Login"}
      </Button>
      <Button
        type="button"
        onClick={handleDMLogin}
        className="w-full mt-2 bg-red-500 hover:bg-red-600 text-white"
        disabled={isLoading}
      >
        DM Login (Testing)
      </Button>
    </form>
  )
}

================
File: app/components/MainContent.tsx
================
"use client"

import { useRef, useState, useEffect, useCallback } from "react"
import Image from "next/image"
import { Button } from "@/components/ui/button"
import { getUserFromCookie } from "@/lib/auth"
import type { LayerImage } from "../types/layerImage"
import DrawingToolbar from "./DrawingToolbar"

interface MainContentProps {
  backgroundImage: string | null
  middleLayerImages: LayerImage[] | undefined
  topLayerImages: LayerImage[] | undefined
  onUpdateImages?: (middleLayer: LayerImage[], topLayer: LayerImage[]) => void
  onUpdateCharacter?: (character: any) => void
  gridSize: number
  gridColor: string
  onGridSizeChange: (size: number) => void
  onGridColorChange: (color: string) => void
  currentTool: 'brush' | 'cursor'
  onToolChange: (tool: 'brush' | 'cursor') => void
  currentColor: string
  onColorChange: (color: string) => void
  sceneScale: number
  zoomLevel: number
  setZoomLevel: React.Dispatch<React.SetStateAction<number>>
}

export default function MainContent({
  backgroundImage,
  middleLayerImages = [],
  topLayerImages = [],
  onUpdateImages,
  onUpdateCharacter,
  gridSize,
  gridColor,
  onGridSizeChange,
  onGridColorChange,
  currentTool,
  onToolChange,
  currentColor,
  onColorChange,
  sceneScale = 1,
  zoomLevel,
  setZoomLevel,
}: MainContentProps) {
  const gridRef = useRef<HTMLDivElement>(null)
  const containerRef = useRef<HTMLDivElement>(null)
  const IMAGE_MAX_SIZE = 1200
  const IMAGE_MIN_SIZE = 50
  const [selectedIds, setSelectedIds] = useState<string[]>([])
  const [draggingIds, setDraggingIds] = useState<string[] | null>(null)
  const [resizingId, setResizingId] = useState<string | null>(null)
  const [dragOffset, setDragOffset] = useState<{ x: number; y: number } | null>(null)
  const [resizeStart, setResizeStart] = useState<{ x: number; y: number; width: number; height: number } | null>(null)
  const [userRole, setUserRole] = useState<string | null>(null)
  const [showColorMenu, setShowColorMenu] = useState(false)
  const [statusModal, setStatusModal] = useState<{
    isOpen: boolean;
    type: 'guard' | 'strength' | 'mp';
    currentValue: number;
    maxValue: number;
    characterId: number;
    character: any;
  } | null>(null)
  const [imageDimensions, setImageDimensions] = useState<{ width: number; height: number } | null>(null)
  const [isPanning, setIsPanning] = useState(false)
  const [panStart, setPanStart] = useState<{ x: number; y: number } | null>(null)
  const [panOffset, setPanOffset] = useState<{ x: number; y: number }>({ x: 0, y: 0 })
  
  // Drawing state
  const [isDrawing, setIsDrawing] = useState(false)
  const [currentPath, setCurrentPath] = useState<string>("")
  const [drawings, setDrawings] = useState<Array<{id: string, path: string, color: string, sceneId: string, createdBy: number, createdAt: string}>>([])
  const [selectedDrawingIds, setSelectedDrawingIds] = useState<string[]>([])
  const [userId, setUserId] = useState<number | null>(null)
  const [sceneId, setSceneId] = useState<string | null>(null)
  const [isLoadingDrawings, setIsLoadingDrawings] = useState(false)

  useEffect(() => {
    const fetchUser = async () => {
      const user = await getUserFromCookie()
      setUserRole(user?.role || null)
      setUserId(user?.id || null)
    }
    fetchUser()
  }, [])

  useEffect(() => {
    if (backgroundImage) {
      const match = backgroundImage.match(/\/api\/images\/([^\/]+)/)
      if (match && match[1]) {
        const newSceneId = match[1];
        
        // Only update if scene has changed
        if (newSceneId !== sceneId) {
          console.log(`Switching from scene ${sceneId} to ${newSceneId}`);
          
          // Clear drawing state
          setCurrentPath('');
          setIsDrawing(false);
          setSelectedDrawingIds([]);
          
          // Set new scene ID
          setSceneId(newSceneId);
        }
      }
    } else {
      // Clear all drawing state when no scene is loaded
      setDrawings([]);
      setCurrentPath('');
      setIsDrawing(false);
      setSelectedDrawingIds([]);
      setSceneId(null);
    }
  }, [backgroundImage, sceneId])

  useEffect(() => {
    if (backgroundImage) {
      const img = new window.Image()
      img.src = backgroundImage
      img.onload = () => {
        // Apply scale to image dimensions
        const scaledWidth = Math.round(img.width * sceneScale);
        const scaledHeight = Math.round(img.height * sceneScale);
        setImageDimensions({ width: scaledWidth, height: scaledHeight })
      }
    } else {
      setImageDimensions(null)
    }
  }, [backgroundImage, sceneScale])

  useEffect(() => {
    const savedZoom = localStorage.getItem('dmScreenZoomLevel')
    if (savedZoom) {
      setZoomLevel(parseFloat(savedZoom))
    }
  }, [setZoomLevel])

  useEffect(() => {
    localStorage.setItem('dmScreenZoomLevel', zoomLevel.toString())
  }, [zoomLevel])

  const generateUniqueId = useCallback((baseId: string) => `${baseId}-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`, [])

  const adjustImageSize = useCallback((width: number, height: number): { width: number; height: number } => {
    let newWidth = width
    let newHeight = height
    const aspectRatio = width / height

    if (width > IMAGE_MAX_SIZE || height > IMAGE_MAX_SIZE) {
      if (width > height) {
        newWidth = IMAGE_MAX_SIZE
        newHeight = Math.round(IMAGE_MAX_SIZE / aspectRatio)
      } else {
        newHeight = IMAGE_MAX_SIZE
        newWidth = Math.round(IMAGE_MAX_SIZE * aspectRatio)
      }
    }

    if (newWidth < IMAGE_MIN_SIZE || newHeight < IMAGE_MIN_SIZE) {
      if (newWidth < newHeight) {
        newWidth = IMAGE_MIN_SIZE
        newHeight = Math.round(IMAGE_MIN_SIZE / aspectRatio)
      } else {
        newHeight = IMAGE_MIN_SIZE
        newWidth = Math.round(IMAGE_MIN_SIZE * aspectRatio)
      }
    }

    return { width: newWidth, height: newHeight }
  }, [])

  const snapToGrid = useCallback((layer: LayerImage[], newGridSize: number) => {
    return layer.map((item) => ({
      ...item,
      x: Math.floor(item.x / newGridSize) * newGridSize,
      y: Math.floor(item.y / newGridSize) * newGridSize,
      ...(item.width === gridSize && item.height === gridSize ? { width: newGridSize, height: newGridSize } : {}),
    }))
  }, [gridSize])

  const updateItemPosition = useCallback((id: string, dx: number, dy: number) => {
    const updateLayer = (layer: LayerImage[]) =>
      layer.map((item) =>
        draggingIds?.includes(item.id)
          ? { ...item, x: Math.floor((item.x + dx) / gridSize) * gridSize, y: Math.floor((item.y + dy) / gridSize) * gridSize }
          : item
      )
    const newMiddleLayer = updateLayer(middleLayerImages)
    const newTopLayer = updateLayer(topLayerImages)
    return { middleLayer: newMiddleLayer, topLayer: newTopLayer }
  }, [draggingIds, gridSize, middleLayerImages, topLayerImages])

  const updateItemSize = useCallback((id: string, width: number, height: number) => {
    const updateLayer = (layer: LayerImage[]) =>
      layer.map((item) => (item.id === id ? { ...item, width, height } : item))
    const newMiddleLayer = updateLayer(middleLayerImages)
    return { middleLayer: newMiddleLayer, topLayer: topLayerImages }
  }, [middleLayerImages, topLayerImages])

  const handleDrop = useCallback(async (e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault()
    const imageId = e.dataTransfer.getData("imageId")
    const category = e.dataTransfer.getData("category")
    const url = e.dataTransfer.getData("url")
    const characterId = e.dataTransfer.getData("characterId")
    const characterData = e.dataTransfer.getData("character")
    
    const rect = gridRef.current?.getBoundingClientRect()
    if (!rect) return

    // Adjust for zoom level when calculating position
    const adjustedX = (e.clientX - rect.left) / zoomLevel
    const adjustedY = (e.clientY - rect.top) / zoomLevel

    const x = Math.floor(adjustedX / gridSize) * gridSize
    const y = Math.floor(adjustedY / gridSize) * gridSize

    const image = new window.Image()
    image.src = url
    await new Promise((resolve) => {
      image.onload = resolve
    })

    const uniqueId = generateUniqueId(imageId)
    const imageData: LayerImage = { id: uniqueId, url: url || "", x, y }
    if (category === "Image") {
      // Keep original size for scene images
      imageData.width = image.width
      imageData.height = image.height
    } else if (category === "Token") {
      imageData.width = gridSize
      imageData.height = gridSize
      if (characterId && characterData) {
        try {
          const parsedCharacter = JSON.parse(characterData)
          imageData.characterId = parseInt(characterId)
          imageData.character = {
            Name: parsedCharacter.Name,
            Path: parsedCharacter.Path,
            Guard: parsedCharacter.Guard ?? 0,
            MaxGuard: parsedCharacter.MaxGuard ?? 0,
            Strength: parsedCharacter.Strength ?? 0,
            MaxStrength: parsedCharacter.MaxStrength ?? 0,
            Mp: parsedCharacter.Mp ?? 0,
            MaxMp: parsedCharacter.MaxMp ?? 0
          }
        } catch (error) {
          console.error('MainContent - Error parsing character data:', error);
        }
      }
    }
    if (category === "Image") {
      onUpdateImages?.([...middleLayerImages, imageData], topLayerImages)
    } else if (category === "Token") {
      onUpdateImages?.(middleLayerImages, [...topLayerImages, imageData])
    }
  }, [gridSize, adjustImageSize, generateUniqueId, middleLayerImages, topLayerImages, onUpdateImages, zoomLevel])

  const handleDragOver = useCallback((e: React.DragEvent<HTMLDivElement>) => {
    e.preventDefault()
  }, [])

  const handleItemDragStart = useCallback((e: React.DragEvent<HTMLDivElement>, item: LayerImage, isToken: boolean) => {
    let dragIds = selectedIds
    if (selectedIds.length === 0) {
      // If nothing is selected, select this item and start dragging it immediately
      setSelectedIds([item.id])
      dragIds = [item.id]
    } else if (!selectedIds.includes(item.id)) {
      // If something is selected but not this item, don't drag
      return
    }
    setDraggingIds(dragIds)
    const rect = e.currentTarget.getBoundingClientRect()
    setDragOffset({
      x: (e.clientX - rect.left),
      y: (e.clientY - rect.top),
    })
    const canvas = document.createElement("canvas")
    const ctx = canvas.getContext("2d")
    if (ctx) {
      canvas.width = item.width || gridSize
      canvas.height = item.height || gridSize
      const img = new window.Image()
      img.src = item.url
      img.onload = () => {
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height)
        e.dataTransfer.setDragImage(canvas, canvas.width / 2, canvas.height / 2)
      }
    }
  }, [selectedIds, gridSize])

  const handleItemDrag = useCallback((e: React.DragEvent<HTMLDivElement>) => {
    if (!draggingIds || !dragOffset || e.clientX === 0 || e.clientY === 0) return
    const rect = gridRef.current?.getBoundingClientRect()
    if (!rect) return

    const referenceItem = middleLayerImages.find((i) => i.id === draggingIds[0]) || topLayerImages.find((i) => i.id === draggingIds[0])
    if (!referenceItem) return

    // Adjust for zoom level when calculating position
    const adjustedX = (e.clientX - rect.left) / zoomLevel
    const adjustedY = (e.clientY - rect.top) / zoomLevel
    
    const newX = Math.floor((adjustedX - dragOffset.x / zoomLevel) / gridSize) * gridSize
    const newY = Math.floor((adjustedY - dragOffset.y / zoomLevel) / gridSize) * gridSize
    
    const dx = newX - referenceItem.x
    const dy = newY - referenceItem.y

    const { middleLayer, topLayer } = updateItemPosition(referenceItem.id, dx, dy)
    onUpdateImages?.(middleLayer, topLayer)
  }, [draggingIds, dragOffset, gridSize, middleLayerImages, topLayerImages, updateItemPosition, onUpdateImages, zoomLevel])

  const handleItemDragEnd = useCallback(() => {
    setDraggingIds(null)
    setDragOffset(null)
    onUpdateImages?.(middleLayerImages, topLayerImages)
  }, [middleLayerImages, topLayerImages, onUpdateImages])

  const handleResizeStart = useCallback((e: React.MouseEvent<HTMLDivElement>, item: LayerImage) => {
    e.preventDefault()
    e.stopPropagation()
    setResizingId(item.id)
    setResizeStart({
      x: e.clientX,
      y: e.clientY,
      width: item.width || gridSize,
      height: item.height || gridSize,
    })
  }, [gridSize])

  const handleResizeMove = useCallback((e: MouseEvent) => {
    if (!resizingId || !resizeStart) return
    
    // Adjust for zoom level when calculating resize
    const dx = (e.clientX - resizeStart.x) / zoomLevel
    const dy = (e.clientY - resizeStart.y) / zoomLevel
    
    const newWidth = Math.max(gridSize, Math.floor((resizeStart.width + dx) / gridSize) * gridSize)
    const newHeight = Math.max(gridSize, Math.floor((resizeStart.height + dy) / gridSize) * gridSize)

    const { middleLayer, topLayer } = updateItemSize(resizingId, newWidth, newHeight)
    onUpdateImages?.(middleLayer, topLayer)
  }, [resizingId, resizeStart, gridSize, updateItemSize, onUpdateImages, zoomLevel])

  const handleResizeEnd = useCallback(() => {
    setResizingId(null)
    setResizeStart(null)
    onUpdateImages?.(middleLayerImages, topLayerImages)
  }, [middleLayerImages, topLayerImages, onUpdateImages])

  const handleDelete = useCallback((e: KeyboardEvent) => {
    if (e.key === "Delete" && selectedIds.length > 0) {
      const newMiddleLayer = middleLayerImages.filter((img) => !selectedIds.includes(img.id))
      const newTopLayer = topLayerImages.filter((img) => !selectedIds.includes(img.id))
      onUpdateImages?.(newMiddleLayer, newTopLayer)
      setSelectedIds([])
    }
    if (e.key === "Delete" && selectedDrawingIds.length > 0) {
      // Update local state for immediate UI response
      const newDrawings = drawings.filter((drawing) => !selectedDrawingIds.includes(drawing.id))
      setDrawings(newDrawings)
      
      // Delete drawings from the database
      selectedDrawingIds.forEach(id => {
        fetch(`/api/drawings?id=${id}`, {
          method: 'DELETE',
        }).catch(error => {
          console.error('Error deleting drawing:', error);
        });
      });
      
      // Clear selection
      setSelectedDrawingIds([])
    }
  }, [selectedIds, middleLayerImages, topLayerImages, onUpdateImages, selectedDrawingIds, drawings])

  const handleGridClick = useCallback((e: React.MouseEvent<HTMLDivElement>) => {
    // Check if we're clicking on the background and not on a token or image
    const target = e.target as HTMLElement;
    const isClickingToken = target.classList.contains('token-image') || 
                           target.closest('.token-image') ||
                           target.closest('[draggable="true"]');
    
    if (!isClickingToken && currentTool !== 'brush') {
      setSelectedIds([]);
      setSelectedDrawingIds([]);
    }
  }, [currentTool]);

  const handleItemClick = useCallback((e: React.MouseEvent<HTMLDivElement>, item: LayerImage) => {
    e.stopPropagation()
    if (currentTool === 'brush') return;
    
    if (e.shiftKey) {
      setSelectedIds((prev) => prev.includes(item.id) ? prev.filter((id) => id !== item.id) : [...prev, item.id])
    } else {
      setSelectedIds([item.id])
    }
  }, [currentTool])

  const handleDrawingClick = useCallback((e: React.MouseEvent<SVGPathElement>, drawing: {id: string, path: string, color: string, sceneId: string, createdBy: number, createdAt: string}) => {
    e.stopPropagation()
    if (currentTool === 'brush') return;
    
    if (e.shiftKey) {
      setSelectedDrawingIds((prev) => prev.includes(drawing.id) ? prev.filter((id) => id !== drawing.id) : [...prev, drawing.id])
    } else {
      setSelectedDrawingIds([drawing.id])
    }
  }, [currentTool])

  const handleWheel = useCallback((e: React.WheelEvent<HTMLDivElement>) => {
    if (e.ctrlKey) {
      e.preventDefault()
      const delta = e.deltaY > 0 ? -0.1 : 0.1
      setZoomLevel(prev => Math.max(0.5, Math.min(3, prev + delta)))
    } else if (e.shiftKey && userRole === "DM") {
      e.preventDefault()
      const newSize = Math.min(200, Math.max(20, gridSize + (e.deltaY < 0 ? 5 : -5)))
      onGridSizeChange(newSize)
      const newMiddleLayer = snapToGrid(middleLayerImages, newSize)
      const newTopLayer = snapToGrid(topLayerImages, newSize)
      onUpdateImages?.(newMiddleLayer, newTopLayer)
    }
  }, [userRole, gridSize, middleLayerImages, topLayerImages, onUpdateImages, snapToGrid, onGridSizeChange])

  const handleKeyDown = useCallback((e: KeyboardEvent) => {
    if (selectedIds.length === 1) {
      const id = selectedIds[0]
      const item = middleLayerImages.find((i) => i.id === id) || topLayerImages.find((i) => i.id === id)
      if (!item) return

      let dx = 0
      let dy = 0
      switch (e.key) {
        case "ArrowUp":
          dy = -gridSize
          break
        case "ArrowDown":
          dy = gridSize
          break
        case "ArrowLeft":
          dx = -gridSize
          break
        case "ArrowRight":
          dx = gridSize
          break
        default:
          return
      }
      const { middleLayer, topLayer } = updateItemPosition(id, dx, dy)
      onUpdateImages?.(middleLayer, topLayer)
    }
  }, [selectedIds, gridSize, middleLayerImages, topLayerImages, updateItemPosition, onUpdateImages])

  const handleColorChange = useCallback((color: string) => {
    onGridColorChange(color === "hidden" ? "transparent" : color === "gray" ? "rgba(0,0,0,0.1)" : color)
    setShowColorMenu(false)
  }, [onGridColorChange])

  const handleStatusUpdate = (value: number) => {
    if (!statusModal) return;
    
    const { type, characterId, character } = statusModal;

    // Create the updated character with the new value first
    const updatedCharacter = {
      Name: character.Name,
      Path: character.Path || (type === 'mp' ? "Magic User" : "Warrior"),
      Guard: type === 'guard' ? value : character.Guard || 0,
      MaxGuard: character.MaxGuard || 0,
      Strength: type === 'strength' ? value : character.Strength || 0,
      MaxStrength: character.MaxStrength || 0,
      Mp: type === 'mp' ? value : character.Mp || 0,
      MaxMp: character.MaxMp || 0
    };

    // Immediately update the UI
    const updatedTopLayer = topLayerImages.map(item => {
      if (item.characterId === characterId) {
        return {
          ...item,
          character: updatedCharacter
        };
      }
      return item;
    });

    // Force a state update with the new data
    onUpdateImages?.(middleLayerImages, updatedTopLayer);
    setStatusModal(null);

    // Update the database asynchronously
    fetch(`/api/characters/${characterId}`, {
      method: 'PUT',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        [type === 'guard' ? 'Guard' : type === 'strength' ? 'Strength' : 'Mp']: value,
        CharacterId: characterId
      }),
    }).catch(() => {
      // If the database update fails, revert the UI change
      const revertedTopLayer = topLayerImages.map(item => 
        item.characterId === characterId
          ? { ...item, character }
          : item
      );
      onUpdateImages?.(middleLayerImages, revertedTopLayer);
    });
  };

  const handleNavigationDragStart = useCallback((e?: React.MouseEvent<HTMLDivElement>) => {
    // Only start panning on middle mouse button or Alt+left click
    // OR when using cursor tool with left click (not on a token)
    if (e) {
      const isAltClick = e.button === 0 && e.altKey;
      const isMiddleClick = e.button === 1;
      const isLeftClickWithCursor = e.button === 0 && currentTool === 'cursor';
      
      if (isMiddleClick || isAltClick || isLeftClickWithCursor) {
        // Check if we're clicking on a token or image when using cursor tool
        if (isLeftClickWithCursor) {
          const target = e.target as HTMLElement;
          const isClickingToken = target.classList.contains('token-image') || 
                                target.closest('.token-image') ||
                                target.closest('[draggable="true"]');
          
          // Don't start panning if clicking on a token
          if (isClickingToken) {
            return;
          }
        }
        
        setIsPanning(true);
        setPanStart({ x: e.clientX, y: e.clientY });
        e.preventDefault();
      }
    }
  }, [currentTool]);

  const handleNavigationDrag = useCallback((e?: React.MouseEvent<HTMLDivElement>) => {
    if (isPanning && panStart && e) {
      const dx = e.clientX - panStart.x;
      const dy = e.clientY - panStart.y;
      
      const containerEl = containerRef.current;
      if (containerEl) {
        // Update scroll position based on mouse movement
        containerEl.scrollLeft = panOffset.x - dx;
        containerEl.scrollTop = panOffset.y - dy;
      }
      
      e.preventDefault();
    }
  }, [isPanning, panStart, panOffset]);

  const handleNavigationDragEnd = useCallback((e?: React.MouseEvent<HTMLDivElement>) => {
    if (isPanning) {
      const containerEl = containerRef.current;
      if (containerEl) {
        setPanOffset({
          x: containerEl.scrollLeft,
          y: containerEl.scrollTop
        });
      }
      
      setIsPanning(false);
      setPanStart(null);
      e?.preventDefault();
    }
  }, [isPanning]);

  const handleZoomIn = useCallback(() => {
    setZoomLevel(prev => Math.min(prev + 0.1, 3)) // Max zoom: 3x
  }, [setZoomLevel])

  const handleZoomOut = useCallback(() => {
    setZoomLevel(prev => Math.max(prev - 0.1, 0.5)) // Min zoom: 0.5x
  }, [setZoomLevel])

  const handleZoomReset = useCallback(() => {
    setZoomLevel(1) // Reset to 1x zoom
    setPanOffset({ x: 0, y: 0 }) // Reset pan offset
  }, [setZoomLevel])

  // Drawing handlers
  const startDrawing = useCallback((e: React.MouseEvent<HTMLDivElement>) => {
    if (currentTool !== 'brush') return;
    
    // Prevent drawing from starting if we're panning
    if (e.button !== 0 || e.altKey) return;
    
    const rect = gridRef.current?.getBoundingClientRect();
    if (!rect) return;
    
    // Adjust for zoom level when calculating position
    const x = (e.clientX - rect.left) / zoomLevel;
    const y = (e.clientY - rect.top) / zoomLevel;
    
    setIsDrawing(true);
    setCurrentPath(`M${x},${y}`);
    
    // Prevent default to avoid text selection
    e.preventDefault();
  }, [currentTool, zoomLevel]);
  
  const draw = useCallback((e: React.MouseEvent<HTMLDivElement>) => {
    if (!isDrawing || currentTool !== 'brush') return;
    
    const rect = gridRef.current?.getBoundingClientRect();
    if (!rect) return;
    
    // Adjust for zoom level when calculating position
    const x = (e.clientX - rect.left) / zoomLevel;
    const y = (e.clientY - rect.top) / zoomLevel;
    
    setCurrentPath(prev => `${prev} L${x},${y}`);
    
    // Prevent default to avoid text selection
    e.preventDefault();
  }, [isDrawing, currentTool, zoomLevel]);
  
  const endDrawing = useCallback((e?: React.MouseEvent<any>) => {
    if (!isDrawing || !currentPath || currentTool !== 'brush') return;
    
    // Prevent default to avoid text selection
    e?.preventDefault();
    
    // Don't save if no scene is selected
    if (!sceneId) {
      setIsDrawing(false);
      setCurrentPath('');
      return;
    }
    
    // Generate a unique ID for the drawing
    const drawingId = `drawing-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    // Create the new drawing object
    const newDrawing = {
      id: drawingId,
      path: currentPath,
      color: currentColor,
      sceneId: sceneId,
      createdBy: userId || 0,
      createdAt: new Date().toISOString()
    };
    
    // Update local state with the new drawing
    setDrawings(prevDrawings => [...prevDrawings, newDrawing]);
    
    // Reset drawing state
    setIsDrawing(false);
    setCurrentPath('');
    
    // Save the drawing to the database
    fetch('/api/drawings', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(newDrawing),
    }).catch((error) => {
      console.error('Error saving drawing:', error);
    });
  }, [isDrawing, currentPath, currentTool, currentColor, sceneId, userId]);
  
  const handleMouseLeave = useCallback(() => {
    if (isDrawing) {
      endDrawing();
    }
  }, [isDrawing, endDrawing]);

  useEffect(() => {
    const handleGlobalKeyDown = (e: KeyboardEvent) => {
      handleDelete(e)
      handleKeyDown(e)
    }
    window.addEventListener("mousemove", handleResizeMove)
    window.addEventListener("mouseup", handleResizeEnd)
    window.addEventListener("keydown", handleGlobalKeyDown)
    
    // Add global mouse up handler for navigation
    const handleGlobalMouseUp = () => {
      handleNavigationDragEnd()
    }
    window.addEventListener("mouseup", handleGlobalMouseUp)
    
    return () => {
      window.removeEventListener("mousemove", handleResizeMove)
      window.removeEventListener("mouseup", handleResizeEnd)
      window.removeEventListener("keydown", handleGlobalKeyDown)
      window.removeEventListener("mouseup", handleGlobalMouseUp)
    }
  }, [handleResizeMove, handleResizeEnd, handleDelete, handleKeyDown, handleNavigationDragEnd])

  useEffect(() => {
    if (sceneId) {
      setIsLoadingDrawings(true);
      fetch(`/api/drawings?sceneId=${sceneId}`)
        .then(response => response.json())
        .then(data => {
          setDrawings(data);
          setIsLoadingDrawings(false);
        })
        .catch(error => {
          console.error('Error loading drawings:', error);
          setIsLoadingDrawings(false);
        });
    } else {
      setDrawings([]);
    }
  }, [sceneId]);

  return (
    <div className="flex flex-col h-full w-full overflow-hidden">
      <div 
        ref={containerRef}
        className="flex-grow relative overflow-auto"
        style={{ 
          cursor: isPanning ? 'grabbing' : 'grab',
          userSelect: 'none' // Prevent text selection during dragging
        }}
        onWheel={handleWheel}
        onMouseDown={handleNavigationDragStart}
        onMouseMove={handleNavigationDrag}
        onMouseUp={handleNavigationDragEnd}
        onMouseLeave={handleNavigationDragEnd}
      >
        {userRole === "DM" && (
          <div className="absolute top-2 left-2 z-30" style={{ 
            position: 'sticky',
            transform: 'none'
          }}>
            <DrawingToolbar
              currentTool={currentTool}
              onToolChange={onToolChange}
              currentColor={currentColor}
              onColorChange={onColorChange}
              gridColor={gridColor}
              onGridColorChange={onGridColorChange}
            />
                    <div className="flex items-center space-x-2">
          <button 
            onClick={handleZoomOut}
            className="w-6 h-6 flex items-center justify-center bg-stone-300 hover:stone-500 rounded-full"
            title="Zoom Out"
          >
            <span className="text-sm">−</span>
          </button>
          <div className="text-xs font-medium w-12 text-center bg-stone-300 rounded">
            {Math.round(zoomLevel * 100)}%
          </div>
          <button 
            onClick={handleZoomIn}
            className="w-6 h-6 flex items-center justify-center bg-stone-300 hover:stone-500 rounded-full"
            title="Zoom In"
          >
            <span className="text-sm">+</span>
          </button>
          <button 
            onClick={handleZoomReset}
            className="ml-1 px-2 py-1 text-xs bg-stone-300 hover:stone-500 rounded"
            title="Reset Zoom"
          >
            Reset
          </button>
        </div>
          </div>
        )}
        <div
          ref={gridRef}
          className="relative"
          style={{
            cursor: currentTool === "brush" ? "crosshair" : "default",
            transform: `scale(${zoomLevel})`,
            transformOrigin: "0 0",
            width: imageDimensions?.width || "100%",
            height: imageDimensions?.height || "100%",
          }}
        >
          <div
            className="absolute inset-0"
            style={{
              backgroundImage: backgroundImage ? `url(${backgroundImage})` : "none",
              backgroundSize: "contain",
              backgroundRepeat: "no-repeat",
              backgroundPosition: "center",
              width: "100%",
              height: "100%",
            }}
            onDragOver={handleDragOver}
            onDrop={handleDrop}
            onClick={handleGridClick}
            onMouseDown={(e) => {
              if (currentTool === 'brush') {
                startDrawing(e);
                // Prevent navigation drag when using brush tool
                e.stopPropagation();
              } else {
                handleNavigationDragStart(e);
              }
            }}
            onMouseMove={(e) => {
              if (isDrawing && currentTool === 'brush') {
                draw(e);
                // Prevent navigation drag when drawing
                e.stopPropagation();
              } else {
                handleNavigationDrag(e);
              }
            }}
            onMouseUp={(e) => {
              if (isDrawing && currentTool === 'brush') {
                endDrawing(e);
                // Prevent navigation drag end when finishing drawing
                e.stopPropagation();
              } else {
                handleNavigationDragEnd(e);
              }
            }}
            onMouseLeave={(e) => {
              if (isDrawing) {
                endDrawing(e);
              }
              handleNavigationDragEnd(e);
            }}
          >
            <div
              className="absolute inset-0 pointer-events-none"
              style={{
                backgroundImage: `linear-gradient(to right, ${gridColor} 1px, transparent 1px), linear-gradient(to bottom, ${gridColor} 1px, transparent 1px)`,
                backgroundSize: `${gridSize}px ${gridSize}px`,
                width: "100%",
                height: "100%",
              }}
            />
            {middleLayerImages.map((img) => (
              <div
                key={img.id}
                className={`absolute ${selectedIds.includes(img.id) ? "border-2 border-blue-500" : ""}`}
                style={{ left: img.x, top: img.y, zIndex: 10 }}
                draggable={true}
                onDragStart={(e) => handleItemDragStart(e, img, false)}
                onDrag={(e) => handleItemDrag(e)}
                onDragEnd={handleItemDragEnd}
                onClick={(e) => handleItemClick(e, img)}
              >
                <Image
                  src={img.url}
                  alt="Middle layer image"
                  width={img.width || gridSize * 2}
                  height={img.height || gridSize * 2}
                  style={{ objectFit: 'contain' }}
                />
                <div
                  className="absolute bottom-0 right-0 w-4 h-4 bg-gray-500 cursor-se-resize"
                  onMouseDown={(e) => handleResizeStart(e, img)}
                />
              </div>
            ))}
            <svg className="absolute inset-0 w-full h-full" style={{ zIndex: 20 }}>
              {drawings.map((drawing) => (
                <path
                  key={drawing.id}
                  d={drawing.path}
                  stroke={selectedDrawingIds.includes(drawing.id) ? "blue" : drawing.color}
                  strokeWidth={selectedDrawingIds.includes(drawing.id) ? "5" : "3"}
                  fill="none"
                  strokeLinejoin="round"
                  strokeLinecap="round"
                  onClick={(e) => handleDrawingClick(e, drawing)}
                  className={`${currentTool === 'cursor' ? 'cursor-pointer' : ''}`}
                  style={{ pointerEvents: currentTool === 'cursor' ? 'auto' : 'none' }}
                />
              ))}
              {isDrawing && currentPath && (
                <path
                  d={currentPath}
                  stroke={currentColor}
                  strokeWidth="3"
                  fill="none"
                  strokeLinejoin="round"
                  strokeLinecap="round"
                />
              )}
            </svg>
            {topLayerImages.map((img) => (
              <div
                key={img.id}
                className={`absolute ${selectedIds.includes(img.id) ? "border-2 border-blue-500" : ""}`}
                style={{ left: img.x, top: img.y, zIndex: 30 }}
                draggable={true}
                onDragStart={(e) => handleItemDragStart(e, img, true)}
                onDrag={(e) => handleItemDrag(e)}
                onDragEnd={handleItemDragEnd}
                onClick={(e) => handleItemClick(e, img)}
              >
                <div className="relative">
                  <Image
                    src={img.url}
                    alt="Token"
                    width={gridSize}
                    height={gridSize}
                    style={{ objectFit: 'contain' }}
                    className="token-image"
                  />
                  {selectedIds.includes(img.id) && img.character && (
                    <div 
                      className="absolute -bottom-6 left-1/2 transform -translate-x-1/2 whitespace-nowrap"
                      style={{ zIndex: 30 }}
                    >
                      <span className="text-sm font-semibold text-black" style={{ 
                        textShadow: `
                          -1px -1px 0 white,
                          1px -1px 0 white,
                          -1px 1px 0 white,
                          1px 1px 0 white
                        `
                      }}>
                        {img.character.Name}
                      </span>
                    </div>
                  )}
                </div>
                {(() => {
                  if (!selectedIds.includes(img.id) || !img.character) return null;
                  
                  const character = img.character;
                  return (
                    <div className="status-circles-container absolute -top-12 left-0 right-0 flex justify-center space-x-3" style={{ zIndex: 50 }}>
                      {/* Guard Circle */}
                      <div className="status-circle guard-circle relative bg-white rounded-full p-1">
                        <div 
                          className="w-8 h-8 rounded-full border-2 border-green-500 flex items-center justify-center text-sm cursor-pointer hover:bg-green-50"
                          onClick={() => setStatusModal({
                            isOpen: true,
                            type: 'guard',
                            currentValue: character.Guard,
                            maxValue: character.MaxGuard,
                            characterId: img.characterId!,
                            character
                          })}
                        >
                          {character.Guard}/{character.MaxGuard}
                        </div>
                        <div className="absolute -top-4 left-1/2 transform -translate-x-1/2 text-[10px] text-gray-500">
                          Gd
                        </div>
                      </div>
                      {/* Strength Circle */}
                      <div className="status-circle strength-circle relative bg-white rounded-full p-1">
                        <div 
                          className="w-8 h-8 rounded-full border-2 border-red-500 flex items-center justify-center text-sm cursor-pointer hover:bg-red-50"
                          onClick={() => setStatusModal({
                            isOpen: true,
                            type: 'strength',
                            currentValue: character.Strength,
                            maxValue: character.MaxStrength,
                            characterId: img.characterId!,
                            character
                          })}
                        >
                          {character.Strength}/{character.MaxStrength}
                        </div>
                        <div className="absolute -top-4 left-1/2 transform -translate-x-1/2 text-[10px] text-gray-500">
                          Str
                        </div>
                      </div>
                      {/* MP Circle (only for Magic Users) */}
                      {character.Path === "Magic User" && (
                        <div className="status-circle mp-circle relative bg-white rounded-full p-1">
                          <div 
                            className="w-8 h-8 rounded-full border-2 border-blue-500 flex items-center justify-center text-sm cursor-pointer hover:bg-blue-50"
                            onClick={() => setStatusModal({
                              isOpen: true,
                              type: 'mp',
                              currentValue: character.Mp,
                              maxValue: character.MaxMp,
                              characterId: img.characterId!,
                              character
                            })}
                          >
                            {character.Mp}/{character.MaxMp}
                          </div>
                          <div className="absolute -top-4 left-1/2 transform -translate-x-1/2 text-[10px] text-gray-500">
                            Mp
                          </div>
                        </div>
                      )}
                    </div>
                  );
                })()}
              </div>
            ))}
          </div>
        </div>
      </div>
      {statusModal && (
        <div 
          className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center z-[100]"
          onClick={() => setStatusModal(null)}
        >
          <div 
            className="bg-white p-6 rounded-lg shadow-lg z-[101]"
            onClick={e => e.stopPropagation()}
          >
            <h3 className="text-lg font-semibold mb-4">
              Update {statusModal.type === 'guard' ? 'Guard' : statusModal.type === 'strength' ? 'Strength' : 'MP'}
            </h3>
            <div className="flex flex-col gap-4">
              <div className="flex items-center space-x-2">
                <input
                  type="number"
                  min="0"
                  value={statusModal.currentValue === 0 ? '' : statusModal.currentValue}
                  onChange={(e) => {
                    const value = e.target.value === '' ? '' : parseInt(e.target.value);
                    setStatusModal(prev => prev ? { ...prev, currentValue: value === '' ? 0 : value } : null);
                  }}
                  className="w-24 px-2 py-1 border rounded"
                  autoFocus
                />
                <span>/ {statusModal.maxValue}</span>
              </div>
              <div className="flex justify-end">
                <Button 
                  onClick={() => handleStatusUpdate(statusModal.currentValue)}
                  className="bg-blue-500 hover:bg-blue-600 text-white"
                >
                  Save
                </Button>
              </div>
            </div>
          </div>
        </div>
      )}

      </div>
  )
}

================
File: app/components/RegisterForm.tsx
================
"use client"

import { useState } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { toast } from "@/components/ui/use-toast"

export default function RegisterForm({ onRegister }) {
  const [username, setUsername] = useState("")
  const [password, setPassword] = useState("")
  const [isLoading, setIsLoading] = useState(false)

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()
    setIsLoading(true)

    try {
      const response = await fetch("/api/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username, password }),
      })

      const data = await response.json()

      if (!response.ok) {
        throw new Error(data.error || "Registration failed")
      }

      onRegister(username)
      toast({
        title: "Registration Successful",
        description: "Welcome to Virtual Tabletop!",
      })
    } catch (error) {
      console.error("Registration error:", error)
      console.error("Full error object:", error)
      toast({
        title: "Registration Failed",
        description: error instanceof Error ? error.message : "An unexpected error occurred",
        variant: "destructive",
      })
    } finally {
      setIsLoading(false)
    }
  }

  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <Input
        type="text"
        placeholder="Username"
        value={username}
        onChange={(e) => setUsername(e.target.value)}
        required
      />
      <Input
        type="password"
        placeholder="Password"
        value={password}
        onChange={(e) => setPassword(e.target.value)}
        required
      />
      <Button type="submit" className="w-full" disabled={isLoading}>
        {isLoading ? "Registering..." : "Register"}
      </Button>
    </form>
  )
}

================
File: app/components/RightSideMenu.tsx
================
"use client"

import { useState, useEffect, useRef } from "react"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Tabs, TabsList, TabsTrigger, TabsContent } from "@/components/ui/tabs"
import { MessageSquare, Users, Map, Settings, LogOut, Trash2, Save, Upload } from "lucide-react"
import CharacterList from "./CharacterList"
import ImageList from "./ImageList"
import { toast } from "@/components/ui/use-toast"
type MessageType = "user" | "system"

interface ChatMessage {
  type: MessageType
  content: string
  timestamp: string
  username: string
}

import { Character } from "../types/character"
import { DMImage } from "../types/image"

interface RightSideMenuProps {
  messages: ChatMessage[]
  addMessage: (type: MessageType, content: string, username: string) => void
  user: {
    id: number;
    username: string;
    role: string;
  }
  chatBackgroundColor: string
  characters: Character[]
  onAddCharacter: (category: string) => void
  onUpdateCharacter: (updatedCharacter: Character) => void
  onDeleteCharacter: (character: Character) => void
  onLogout: () => void
  images: DMImage[]
  onAddImage: (category: string, file: File) => Promise<void>
  onDeleteImage: (image: DMImage) => Promise<void>
  onRenameImage: (image: DMImage, newName: string) => Promise<void>
  onSetBackground: (url: string) => void
  onDropImage: (category: string, image: DMImage, x: number, y: number) => void
  scenes: DMImage[]
  onSaveScene: () => void
  onLoadScene: (scene: DMImage) => void
  onDeleteSceneData: (image: DMImage) => Promise<void>
  onUpdateSceneScale?: (image: DMImage, scale: number) => Promise<void>
  setImages: (images: DMImage[]) => void
}

export default function RightSideMenu({
  messages,
  addMessage,
  user,
  chatBackgroundColor,
  characters,
  onAddCharacter,
  onUpdateCharacter,
  onDeleteCharacter,
  onLogout,
  images,
  onAddImage,
  onDeleteImage,
  onRenameImage,
  onSetBackground,
  onSaveScene,
  onDeleteSceneData,
  onUpdateSceneScale,
  setImages,
}: RightSideMenuProps) {
  const [inputMessage, setInputMessage] = useState("")
  const chatContainerRef = useRef<HTMLDivElement>(null)
  const [activeSection, setActiveSection] = useState<"chat" | "characters" | "maps">("chat")

  // Add effect to refresh images when switching to maps tab
  useEffect(() => {
    if (activeSection === "maps") {
      // Simple direct refresh of images when switching to maps tab
      const refreshImages = async () => {
        try {
          const response = await fetch("/api/images", { credentials: "include" });
          if (response.ok) {
            const updatedImages = await response.json();
            // Directly update the images state in the parent component
            setImages(updatedImages);
            console.log("Images refreshed when switching to maps tab");
          }
        } catch (error) {
          console.error("Error refreshing images:", error);
        }
      };
      refreshImages();
    }
  }, [activeSection, setImages]);

  const handleSendMessage = () => {
    if (inputMessage.trim()) {
      addMessage("user", inputMessage, user.username)
      setInputMessage("")
    }
  }

  const handleDragStart = (e: React.DragEvent<HTMLLIElement>, image: DMImage) => {
    e.dataTransfer.setData("imageId", image.Id.toString())
    e.dataTransfer.setData("category", image.Category)
    e.dataTransfer.setData("url", image.Link)
    if (image.CharacterId) {
      e.dataTransfer.setData("characterId", image.CharacterId.toString())
      e.dataTransfer.setData("character", JSON.stringify(image))
    }
  }

  useEffect(() => {
    if (chatContainerRef.current) {
      chatContainerRef.current.scrollTop = chatContainerRef.current.scrollHeight
    }
  }, [messages])

  const handleLogout = async () => {
    try {
      const response = await fetch("/api/logout", { method: "POST" })
      if (response.ok) {
        onLogout()
      } else {
        throw new Error("Logout failed")
      }
    } catch (error) {
      console.error("Logout error:", error)
      toast({
        title: "Logout Failed",
        description: "An error occurred during logout. Please try again.",
        variant: "destructive",
      })
    }
  }

  return (
    <div className="w-[40rem] bg-white border-l flex flex-col" style={{ backgroundImage: 'url("images/rightsidemenu.jpeg")', backgroundSize: '100% auto', backgroundRepeat: 'repeat-y' }}>
      <div className="p-4 border-b w-full">
        <Tabs value={activeSection} onValueChange={(value) => setActiveSection(value as "chat" | "characters" | "maps")} className="w-full">
          <TabsList className="grid w-full grid-cols-3 bg-stone-300">
            <TabsTrigger value="chat">
              <MessageSquare className="h-4 w-4" />
            </TabsTrigger>
            <TabsTrigger value="characters">
              <Users className="h-4 w-4" />
            </TabsTrigger>
            <TabsTrigger value="maps">
              <Map className="h-4 w-4" />
            </TabsTrigger>
          </TabsList>
          <TabsContent value="chat" className="w-full">
            <div className="flex flex-col h-[calc(100vh-8rem)] w-full">
              <h2 className="text-lg text-white font-semibold p-4 pb-2">Chat</h2>
              <div ref={chatContainerRef} className={`flex-grow px-4 ${chatBackgroundColor} overflow-y-auto rounded bg-opacity-80`}>
                <div className="space-y-2 pb-4">
                  {messages.map((message, index) => {
                    const currentDate = new Date(message.timestamp).toLocaleDateString("en-GB", {
                      day: "2-digit",
                      month: "2-digit",
                      year: "numeric"
                    });
                    const prevMessage = index > 0 ? messages[index - 1] : null;
                    const prevDate = prevMessage ? new Date(prevMessage.timestamp).toLocaleDateString("en-GB", {
                      day: "2-digit",
                      month: "2-digit",
                      year: "numeric"
                    }) : null;
                    const showDateSeparator = prevDate && currentDate !== prevDate;

                    return (
                      <div key={index}>
                        {showDateSeparator && (
                          <div className="text-center text-sm text-gray-500 my-2">
                            {currentDate}
                          </div>
                        )}
                        <div className="text-sm">
                          {message.type === "user" ? (
                            <span className="font-semibold">{message.username}:</span>
                          ) : (
                            <span className="font-semibold text-blue-600">System:</span>
                          )}{" "}
                          <span dangerouslySetInnerHTML={{ __html: message.content }} />
                        </div>
                      </div>
                    );
                  })}
                </div>
              </div>
              <div className="p-2 border-t">
                <div className="flex h-10">
                  <Input
                    type="text"
                    value={inputMessage}
                    onChange={(e) => setInputMessage(e.target.value)}
                    onKeyPress={(e) => e.key === "Enter" && handleSendMessage()}
                    placeholder="Type a message..."
                    className="flex-grow mr-2 bg-yellow-20 bg-stone-200"
                  />
                  <Button onClick={handleSendMessage}>Send</Button>
                </div>
              </div>
            </div>
          </TabsContent>
          <TabsContent value="characters" className="w-full">
            <div className="p-4 w-full">
              <h2 className="text-lg text-white font-semibold mb-4">Characters</h2>
              <CharacterList
                categories={["Party", "NPC", "Monster"]}
                characters={characters}
                onAddCharacter={onAddCharacter}
                onUpdateCharacter={onUpdateCharacter}
                onDeleteCharacter={onDeleteCharacter}
                currentUser={user.id}
                isDM={user.role === "DM"}
              />
            </div>
          </TabsContent>
          <TabsContent value="maps" className="w-full">
            <div className="p-4 w-full">
              <div className="flex justify-between items-center mb-4">
                <h3 className="text-lg text-white font-semibold">Images</h3>
                <div className="space-x-2">
                  <Button onClick={onSaveScene} size="sm" variant="ghost" title="Save Scene" className="bg-white">
                     <Save className="h-4 w-4" />
                    
                  </Button>
                  <Button onClick={() => onAddImage("Scene", new File([], ""))} size="sm">
                   Upload
                  </Button>
                </div>
              </div>
              <div className="mt-4">
                <ImageList
                  images={images}
                  categories={["Scene", "Image", "Token"]}
                  onAddImage={onAddImage}
                  onDeleteImage={onDeleteImage}
                  onDragStart={handleDragStart}
                  onSceneClick={onSetBackground}
                  onDeleteSceneData={onDeleteSceneData}
                  onRenameImage={onRenameImage}
                  onUpdateSceneScale={onUpdateSceneScale}
                  characters={characters}
                />
              </div>
            </div>
          </TabsContent>
        </Tabs>
      </div>
    </div>
  )
}

================
File: app/components/ui/button.tsx
================
import * as React from "react"
import { cn } from "@/lib/utils"

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  variant?: 'default' | 'ghost'
  size?: 'default' | 'icon'
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant = 'default', size = 'default', ...props }, ref) => {
    return (
      <button
        className={cn(
          "inline-flex items-center justify-center rounded-md font-medium transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 disabled:opacity-50 disabled:pointer-events-none",
          variant === 'default' && "bg-primary text-primary-foreground hover:bg-primary/90",
          variant === 'ghost' && "hover:bg-accent hover:text-accent-foreground",
          size === 'default' && "h-10 py-2 px-4",
          size === 'icon' && "h-10 w-10",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button }

================
File: app/components/ui/popover.tsx
================
import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"
import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }

================
File: app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;
 
@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;

    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
 
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
 
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
 
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
 
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
 
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
 
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
 
    --radius: 0.5rem;
  }
 
  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
 
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
 
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
 
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
 
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
 
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
 
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
 
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
 
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
  }
}

/* Scrollbar Styling */
::-webkit-scrollbar {
  width: 8px; /* Width of the entire scrollbar */
}

::-webkit-scrollbar-track {
  background-color: rgba(207, 198, 198, 0.505); /* Track color: Transparent */
}

::-webkit-scrollbar-thumb {
  background-color: stone-300; /* Thumb color: Stone */
  border-radius: 4px; /* Rounded corners for the thumb */
  border: 1px solid #a8a876; /* Outline for the thumb */
}

::-webkit-scrollbar-corner {
  background-color: rgba(207, 198, 198, 0.505);
}

::-webkit-scrollbar-button:hover {
  background-color: #c0c096; /* Darker thumb color on hover */
}

::-webkit-scrollbar-thumb:hover {
  background-color: #c0c096; /* Darker thumb color on hover */
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================
File: app/hooks/useCharacter.ts
================
// hooks/useCharacter.ts
import { useState } from 'react';
import { toast } from "@/components/ui/use-toast";
import { Character } from '../types/character';

export function useCharacter(initialCharacter: Character, onUpdate: (updatedCharacter: Character) => void) {
  const [editedCharacter, setEditedCharacter] = useState<Character>(initialCharacter);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement | HTMLSelectElement>) => {
    const { name, value } = e.target;
    setEditedCharacter(prev => ({ ...prev, [name]: value }));
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const response = await fetch(`/api/characters/${editedCharacter.CharacterId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(editedCharacter),
      });
      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to update character');
      }
      const updatedCharacter = await response.json();
      onUpdate(updatedCharacter);
      toast({ title: "Character Updated", description: "Your changes have been saved successfully." });
    } catch (error) {
      console.error('Error updating character:', error);
      toast({
        title: "Error",
        description: error instanceof Error ? error.message : "Failed to update character.",
        variant: "destructive",
      });
    }
  };

  return { editedCharacter, setEditedCharacter, handleInputChange, handleSubmit };
}

================
File: app/hooks/useInventory.ts
================
// hooks/useInventory.ts
import { useState, useEffect } from 'react';
import { toast } from "@/components/ui/use-toast";

// Define types locally to avoid import issues
interface InventoryItem {
  slot: number;
  name: string;
  description?: string | null;
}

interface Inventory {
  Inventoryid: number;
  Contents: InventoryItem[];
  CharacterId: number;
}

export function useInventory(characterId: number) {
  const [inventory, setInventory] = useState<Inventory | null>(null);
  const [editingSlot, setEditingSlot] = useState<number | null>(null);
  const [inventoryForm, setInventoryForm] = useState<{ name: string; description: string | null; slot: number }>({
    name: '',
    description: null,
    slot: 0,
  });

  useEffect(() => {
    const fetchInventory = async () => {
      try {
        const response = await fetch(`/inventory?characterId=${characterId}`);
        if (!response.ok) {
          throw new Error(`Failed to fetch inventory: ${response.statusText}`);
        }
        const data: Inventory = await response.json();
        setInventory(data);
        console.log("Fetched inventory:", data.Contents);
      } catch (error: any) {
        console.error("Error fetching inventory:", error);
        toast({ title: "Error", description: "Failed to fetch inventory.", variant: "destructive" });
        setInventory({
          Inventoryid: -1,
          CharacterId: characterId,
          Contents: Array.from({ length: 16 }, (_, i) => ({
            slot: i + 1,
            name: '',
            description: null,
          })),
        });
      }
    };
    fetchInventory();
  }, [characterId]);

  const handleInventoryEdit = (slot: number) => {
    setEditingSlot(slot);
    const item = inventory?.Contents.find(item => item.slot === slot) || { slot, name: '', description: null };
    setInventoryForm({ name: item.name, description: item.description ?? null, slot: item.slot });
  };

  const handleInventoryFormChange = (field: keyof typeof inventoryForm, value: string | number) => {
    if (inventoryForm) {
      setInventoryForm({
        ...inventoryForm,
        [field]: field === 'slot' ? parseInt(value as string) || 0 : value,
      });
    }
  };

  const handleInventorySubmit = async (slot: number) => {
    if (!inventory || !inventoryForm) return;

    try {
      let inventoryId = inventory.Inventoryid;
      let contents = inventory.Contents;

      // If inventory doesn't exist (Inventoryid is -1), create a new one
      if (inventoryId === -1) {
        const initialContents = Array.from({ length: 16 }, (_, i) => ({
          slot: i + 1,
          name: '',
          description: null,
        }));
        const createResponse = await fetch(`/inventory?characterId=${characterId}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ characterId, contents: initialContents }),
        });
        if (!createResponse.ok) throw new Error(`Failed to create inventory: ${createResponse.statusText}`);
        const createdInventory: Inventory = await createResponse.json();
        inventoryId = createdInventory.Inventoryid;
        contents = createdInventory.Contents;
        setInventory(createdInventory);
      }

      // Update the contents with the new data
      const updatedContents = contents.map(item =>
        item.slot === slot
          ? { slot, name: inventoryForm.name, description: inventoryForm.description }
          : item
      );

      // Update the inventory
      const response = await fetch(`/inventory`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ inventoryId, contents: updatedContents }),
      });
      if (!response.ok) throw new Error(`Failed to update inventory: ${response.statusText}`);
      const updatedInventory: Inventory = await response.json();
      setInventory(updatedInventory);
      setEditingSlot(null);
      setInventoryForm({ name: '', description: null, slot: 0 });
      toast({ title: "Inventory Updated", description: `Slot ${slot} saved successfully.` });
    } catch (error: any) {
      console.error("Error updating inventory:", error);
      toast({ title: "Error", description: "Failed to update inventory.", variant: "destructive" });
    }
  };

  const handleClearSlot = async (slot: number) => {
    if (!inventory) return;

    try {
      let inventoryId = inventory.Inventoryid;
      let contents = inventory.Contents;

      // If inventory doesn't exist (Inventoryid is -1), create a new one
      if (inventoryId === -1) {
        const initialContents = Array.from({ length: 16 }, (_, i) => ({
          slot: i + 1,
          name: '',
          description: null,
        }));
        const createResponse = await fetch(`/inventory?characterId=${characterId}`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ characterId, contents: initialContents }),
        });
        if (!createResponse.ok) throw new Error(`Failed to create inventory: ${createResponse.statusText}`);
        const createdInventory: Inventory = await createResponse.json();
        inventoryId = createdInventory.Inventoryid;
        contents = createdInventory.Contents;
        setInventory(createdInventory);
      }

      // Update the contents to clear the slot
      const updatedContents = contents.map(item =>
        item.slot === slot ? { slot, name: '', description: null } : item
      );

      // Update the inventory
      const response = await fetch(`/inventory`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ inventoryId, contents: updatedContents }),
      });
      if (!response.ok) throw new Error(`Failed to clear slot: ${response.statusText}`);
      const updatedInventory: Inventory = await response.json();
      setInventory(updatedInventory);
      toast({ title: "Slot Cleared", description: `Slot ${slot} cleared.` });
    } catch (error: any) {
      console.error("Error clearing slot:", error);
      toast({ title: "Error", description: "Failed to clear slot.", variant: "destructive" });
    }
  };

  return { inventory, editingSlot, inventoryForm, handleInventoryEdit, handleInventoryFormChange, handleInventorySubmit, handleClearSlot };
}

================
File: app/hooks/useJobs.ts
================
// hooks/useJobs.ts
import { useState, useEffect } from 'react';
import { toast } from "@/components/ui/use-toast";

interface Job {
  JobId: number;
  Name: string;
  Description: string | null;
  Tier: number;
  CharacterId: number;
}

export function useJobs(characterId: number) {
  const [jobs, setJobs] = useState<Job[]>([]);
  const [newJobName, setNewJobName] = useState('');
  const [editingJob, setEditingJob] = useState<number | null>(null);
  const [jobForm, setJobForm] = useState<{ name: string; description: string | null; tier: number }>({
    name: '',
    description: null,
    tier: 0,
  });

  useEffect(() => {
    const fetchJobs = async () => {
      try {
        const response = await fetch(`/api/characters/${characterId}/jobs`);
        if (!response.ok) throw new Error(`Failed to fetch jobs: ${response.statusText}`);
        const data: Job[] = await response.json();
        setJobs(data);
      } catch (error: any) {
        console.error("Error fetching jobs:", error);
        toast({ title: "Error", description: "Failed to fetch jobs.", variant: "destructive" });
      }
    };
    fetchJobs();
  }, [characterId]);

  const handleAddJob = async (e: React.FormEvent) => {
    e.preventDefault();
    if (!newJobName) {
      toast({ title: "Error", description: "Job name is required.", variant: "destructive" });
      return;
    }
    try {
      const response = await fetch(`/api/characters/${characterId}/jobs`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name: newJobName, description: null, tier: 1 }),
      });
      if (!response.ok) throw new Error(`Failed to add job: ${response.statusText}`);
      const newJob: Job = await response.json();
      setJobs([...jobs, newJob]);
      setNewJobName('');
      toast({ title: "Job Added", description: `${newJob.Name} added successfully.` });
    } catch (error: any) {
      console.error("Error adding job:", error);
      toast({ title: "Error", description: "Failed to add job.", variant: "destructive" });
    }
  };

  const handleJobEdit = (job: Job) => {
    setEditingJob(job.JobId);
    setJobForm({ name: job.Name, description: job.Description, tier: job.Tier });
  };

  const handleJobFormChange = (field: keyof typeof jobForm, value: string | number) => {
    if (jobForm) {
      setJobForm({
        ...jobForm,
        [field]: field === 'tier' ? parseInt(value as string) || 0 : value,
      });
    }
  };

  const handleJobSubmit = async (jobId: number) => {
    if (!jobForm) return;
    try {
      const response = await fetch(`/api/characters/${characterId}/jobs/${jobId}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(jobForm),
      });
      if (!response.ok) throw new Error(`Failed to update job: ${response.statusText}`);
      const updatedJob: Job = await response.json();
      setJobs(prevJobs => prevJobs.map(j => (j.JobId === updatedJob.JobId ? updatedJob : j)));
      setEditingJob(null);
      setJobForm({ name: '', description: null, tier: 0 });
      toast({ title: "Job Updated", description: "Job saved successfully." });
    } catch (error: any) {
      console.error("Error updating job:", error);
      toast({ title: "Error", description: "Failed to update job.", variant: "destructive" });
    }
  };

  return { jobs, newJobName, setNewJobName, editingJob, jobForm, handleAddJob, handleJobEdit, handleJobFormChange, handleJobSubmit };
}

================
File: app/layout.tsx
================
import "./globals.css"
import type { Metadata } from "next"
import { Inter } from "next/font/google"
import { Toaster } from "@/components/ui/toaster"
import type React from "react"

const inter = Inter({ subsets: ["latin"] })

export const metadata: Metadata = {
  title: "Virtual Tabletop",
  description: "A virtual tabletop for role-playing games",
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        {children}
        <Toaster />
      </body>
    </html>
  )
}

================
File: app/lib/db.ts
================
import Database from 'better-sqlite3'

const db = new Database('./database.db')

export { db }

================
File: app/lib/prisma.ts
================
import { PrismaClient } from '@prisma/client'

const globalForPrisma = global as unknown as { prisma: PrismaClient }

export const prisma = globalForPrisma.prisma || new PrismaClient()

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma

================
File: app/page.tsx
================
import dynamic from "next/dynamic"
import { Suspense } from "react"

const DynamicHome = dynamic(() => import("./components/Home"), {
  loading: () => <p>Loading...</p>,
  ssr: false,
})

export default function Page() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <DynamicHome />
    </Suspense>
  )
}

================
File: app/types/character.ts
================
export interface Character {
  CharacterId: number
  Name: string
  Description: string
  Path: string
  Category?: string // Capitalized (optional)
  category?: string // Lowercase (optional, for safety)
  UserId: number
  PortraitUrl?: string
  TokenUrl?: string
  Age?: number
  Level?: number
  Armor?: number
  Guard?: number
  MaxGuard?: number
  Strength?: number
  MaxStrength?: number
  Dexternity?: number
  MaxDexternity?: number
  Mind?: number
  MaxMind?: number
  Charisma?: number
  MaxCharisma?: number
  Skill?: number
  MaxSkill?: number
  Mp?: number
  MaxMp?: number
  InventoryId?: number | null
  JobId?: number | null
}

================
File: app/types/image.ts
================
export type DMImage = {
  Id: number;
  Name: string;
  Link: string;
  Category: "Scene" | "Image" | "Token";
  UserId: number;
  SceneData?: string; // JSON string containing scene configuration
  CharacterId?: number; // Reference to the character this token represents
  Character?: {
    Name: string;
    Path: string;
    Guard: number;
    MaxGuard: number;
    Strength: number;
    MaxStrength: number;
    Mp: number;
    MaxMp: number;
  };
};

================
File: app/types/inventory.ts
================
// types/inventory.ts
export interface InventoryItem {
    slot: number;
    name: string;
    description: string | null;
  }
  
  export interface Inventory {
    Inventoryid: number;
    CharacterId: number;
    Contents: InventoryItem[];
  }

================
File: app/types/layerImage.ts
================
export type LayerImage = {
    id: string
    url: string
    x: number
    y: number
    width?: number // Optional for images, not used for tokens
    height?: number // Optional for images, not used for tokens
    characterId?: number // Optional: ID of the character this token represents
    character?: {
      Name: string
      Path: string
      Guard: number
      MaxGuard: number
      Strength: number
      MaxStrength: number
      Mp: number
      MaxMp: number
    }
  }

================
File: app/types/user.ts
================
export interface User {
  id: number;
  username: string;
  role: string;
}

================
File: components.json
================
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "default",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.ts",
    "css": "app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}

================
File: components/theme-provider.tsx
================
'use client'

import * as React from 'react'
import {
  ThemeProvider as NextThemesProvider,
  type ThemeProviderProps,
} from 'next-themes'

export function ThemeProvider({ children, ...props }: ThemeProviderProps) {
  return <NextThemesProvider {...props}>{children}</NextThemesProvider>
}

================
File: components/ui/accordion.tsx
================
"use client"

import * as React from "react"
import * as AccordionPrimitive from "@radix-ui/react-accordion"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const Accordion = AccordionPrimitive.Root

const AccordionItem = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Item>
>(({ className, ...props }, ref) => (
  <AccordionPrimitive.Item
    ref={ref}
    className={cn("border-b", className)}
    {...props}
  />
))
AccordionItem.displayName = "AccordionItem"

const AccordionTrigger = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Header className="flex">
    <AccordionPrimitive.Trigger
      ref={ref}
      className={cn(
        "flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180",
        className
      )}
      {...props}
    >
      {children}
      <ChevronDown className="h-4 w-4 shrink-0 transition-transform duration-200" />
    </AccordionPrimitive.Trigger>
  </AccordionPrimitive.Header>
))
AccordionTrigger.displayName = AccordionPrimitive.Trigger.displayName

const AccordionContent = React.forwardRef<
  React.ElementRef<typeof AccordionPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AccordionPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <AccordionPrimitive.Content
    ref={ref}
    className="overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down"
    {...props}
  >
    <div className={cn("pb-4 pt-0", className)}>{children}</div>
  </AccordionPrimitive.Content>
))

AccordionContent.displayName = AccordionPrimitive.Content.displayName

export { Accordion, AccordionItem, AccordionTrigger, AccordionContent }

================
File: components/ui/alert-dialog.tsx
================
"use client"

import * as React from "react"
import * as AlertDialogPrimitive from "@radix-ui/react-alert-dialog"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

const AlertDialog = AlertDialogPrimitive.Root

const AlertDialogTrigger = AlertDialogPrimitive.Trigger

const AlertDialogPortal = AlertDialogPrimitive.Portal

const AlertDialogOverlay = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
AlertDialogOverlay.displayName = AlertDialogPrimitive.Overlay.displayName

const AlertDialogContent = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Content>
>(({ className, ...props }, ref) => (
  <AlertDialogPortal>
    <AlertDialogOverlay />
    <AlertDialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    />
  </AlertDialogPortal>
))
AlertDialogContent.displayName = AlertDialogPrimitive.Content.displayName

const AlertDialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
AlertDialogHeader.displayName = "AlertDialogHeader"

const AlertDialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
AlertDialogFooter.displayName = "AlertDialogFooter"

const AlertDialogTitle = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold", className)}
    {...props}
  />
))
AlertDialogTitle.displayName = AlertDialogPrimitive.Title.displayName

const AlertDialogDescription = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
AlertDialogDescription.displayName =
  AlertDialogPrimitive.Description.displayName

const AlertDialogAction = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Action>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Action>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Action
    ref={ref}
    className={cn(buttonVariants(), className)}
    {...props}
  />
))
AlertDialogAction.displayName = AlertDialogPrimitive.Action.displayName

const AlertDialogCancel = React.forwardRef<
  React.ElementRef<typeof AlertDialogPrimitive.Cancel>,
  React.ComponentPropsWithoutRef<typeof AlertDialogPrimitive.Cancel>
>(({ className, ...props }, ref) => (
  <AlertDialogPrimitive.Cancel
    ref={ref}
    className={cn(
      buttonVariants({ variant: "outline" }),
      "mt-2 sm:mt-0",
      className
    )}
    {...props}
  />
))
AlertDialogCancel.displayName = AlertDialogPrimitive.Cancel.displayName

export {
  AlertDialog,
  AlertDialogPortal,
  AlertDialogOverlay,
  AlertDialogTrigger,
  AlertDialogContent,
  AlertDialogHeader,
  AlertDialogFooter,
  AlertDialogTitle,
  AlertDialogDescription,
  AlertDialogAction,
  AlertDialogCancel,
}

================
File: components/ui/alert.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border p-4 [&>svg~*]:pl-7 [&>svg+div]:translate-y-[-3px] [&>svg]:absolute [&>svg]:left-4 [&>svg]:top-4 [&>svg]:text-foreground",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "border-destructive/50 text-destructive dark:border-destructive [&>svg]:text-destructive",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Alert = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & VariantProps<typeof alertVariants>
>(({ className, variant, ...props }, ref) => (
  <div
    ref={ref}
    role="alert"
    className={cn(alertVariants({ variant }), className)}
    {...props}
  />
))
Alert.displayName = "Alert"

const AlertTitle = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLHeadingElement>
>(({ className, ...props }, ref) => (
  <h5
    ref={ref}
    className={cn("mb-1 font-medium leading-none tracking-tight", className)}
    {...props}
  />
))
AlertTitle.displayName = "AlertTitle"

const AlertDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm [&_p]:leading-relaxed", className)}
    {...props}
  />
))
AlertDescription.displayName = "AlertDescription"

export { Alert, AlertTitle, AlertDescription }

================
File: components/ui/aspect-ratio.tsx
================
"use client"

import * as AspectRatioPrimitive from "@radix-ui/react-aspect-ratio"

const AspectRatio = AspectRatioPrimitive.Root

export { AspectRatio }

================
File: components/ui/avatar.tsx
================
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }

================
File: components/ui/badge.tsx
================
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

================
File: components/ui/breadcrumb.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"

const Breadcrumb = React.forwardRef<
  HTMLElement,
  React.ComponentPropsWithoutRef<"nav"> & {
    separator?: React.ReactNode
  }
>(({ ...props }, ref) => <nav ref={ref} aria-label="breadcrumb" {...props} />)
Breadcrumb.displayName = "Breadcrumb"

const BreadcrumbList = React.forwardRef<
  HTMLOListElement,
  React.ComponentPropsWithoutRef<"ol">
>(({ className, ...props }, ref) => (
  <ol
    ref={ref}
    className={cn(
      "flex flex-wrap items-center gap-1.5 break-words text-sm text-muted-foreground sm:gap-2.5",
      className
    )}
    {...props}
  />
))
BreadcrumbList.displayName = "BreadcrumbList"

const BreadcrumbItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentPropsWithoutRef<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    className={cn("inline-flex items-center gap-1.5", className)}
    {...props}
  />
))
BreadcrumbItem.displayName = "BreadcrumbItem"

const BreadcrumbLink = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentPropsWithoutRef<"a"> & {
    asChild?: boolean
  }
>(({ asChild, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      className={cn("transition-colors hover:text-foreground", className)}
      {...props}
    />
  )
})
BreadcrumbLink.displayName = "BreadcrumbLink"

const BreadcrumbPage = React.forwardRef<
  HTMLSpanElement,
  React.ComponentPropsWithoutRef<"span">
>(({ className, ...props }, ref) => (
  <span
    ref={ref}
    role="link"
    aria-disabled="true"
    aria-current="page"
    className={cn("font-normal text-foreground", className)}
    {...props}
  />
))
BreadcrumbPage.displayName = "BreadcrumbPage"

const BreadcrumbSeparator = ({
  children,
  className,
  ...props
}: React.ComponentProps<"li">) => (
  <li
    role="presentation"
    aria-hidden="true"
    className={cn("[&>svg]:w-3.5 [&>svg]:h-3.5", className)}
    {...props}
  >
    {children ?? <ChevronRight />}
  </li>
)
BreadcrumbSeparator.displayName = "BreadcrumbSeparator"

const BreadcrumbEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    role="presentation"
    aria-hidden="true"
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More</span>
  </span>
)
BreadcrumbEllipsis.displayName = "BreadcrumbElipssis"

export {
  Breadcrumb,
  BreadcrumbList,
  BreadcrumbItem,
  BreadcrumbLink,
  BreadcrumbPage,
  BreadcrumbSeparator,
  BreadcrumbEllipsis,
}

================
File: components/ui/button.tsx
================
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/90",
        outline:
          "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-10 px-4 py-2",
        sm: "h-9 rounded-md px-3",
        lg: "h-11 rounded-md px-8",
        icon: "h-10 w-10",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

================
File: components/ui/calendar.tsx
================
"use client"

import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

export type CalendarProps = React.ComponentProps<typeof DayPicker>

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: CalendarProps) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row space-y-4 sm:space-x-4 sm:space-y-0",
        month: "space-y-4",
        caption: "flex justify-center pt-1 relative items-center",
        caption_label: "text-sm font-medium",
        nav: "space-x-1 flex items-center",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "h-7 w-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-y-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-9 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: "h-9 w-9 text-center text-sm p-0 relative [&:has([aria-selected].day-range-end)]:rounded-r-md [&:has([aria-selected].day-outside)]:bg-accent/50 [&:has([aria-selected])]:bg-accent first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md focus-within:relative focus-within:z-20",
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "h-9 w-9 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_end: "day-range-end",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:bg-accent/50 aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ ...props }) => <ChevronLeft className="h-4 w-4" />,
        IconRight: ({ ...props }) => <ChevronRight className="h-4 w-4" />,
      }}
      {...props}
    />
  )
}
Calendar.displayName = "Calendar"

export { Calendar }

================
File: components/ui/card.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "rounded-lg border bg-card text-card-foreground shadow-sm",
      className
    )}
    {...props}
  />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props}
  />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn(
      "text-2xl font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props}
  />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }

================
File: components/ui/carousel.tsx
================
"use client"

import * as React from "react"
import useEmblaCarousel, {
  type UseEmblaCarouselType,
} from "embla-carousel-react"
import { ArrowLeft, ArrowRight } from "lucide-react"

import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"

type CarouselApi = UseEmblaCarouselType[1]
type UseCarouselParameters = Parameters<typeof useEmblaCarousel>
type CarouselOptions = UseCarouselParameters[0]
type CarouselPlugin = UseCarouselParameters[1]

type CarouselProps = {
  opts?: CarouselOptions
  plugins?: CarouselPlugin
  orientation?: "horizontal" | "vertical"
  setApi?: (api: CarouselApi) => void
}

type CarouselContextProps = {
  carouselRef: ReturnType<typeof useEmblaCarousel>[0]
  api: ReturnType<typeof useEmblaCarousel>[1]
  scrollPrev: () => void
  scrollNext: () => void
  canScrollPrev: boolean
  canScrollNext: boolean
} & CarouselProps

const CarouselContext = React.createContext<CarouselContextProps | null>(null)

function useCarousel() {
  const context = React.useContext(CarouselContext)

  if (!context) {
    throw new Error("useCarousel must be used within a <Carousel />")
  }

  return context
}

const Carousel = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement> & CarouselProps
>(
  (
    {
      orientation = "horizontal",
      opts,
      setApi,
      plugins,
      className,
      children,
      ...props
    },
    ref
  ) => {
    const [carouselRef, api] = useEmblaCarousel(
      {
        ...opts,
        axis: orientation === "horizontal" ? "x" : "y",
      },
      plugins
    )
    const [canScrollPrev, setCanScrollPrev] = React.useState(false)
    const [canScrollNext, setCanScrollNext] = React.useState(false)

    const onSelect = React.useCallback((api: CarouselApi) => {
      if (!api) {
        return
      }

      setCanScrollPrev(api.canScrollPrev())
      setCanScrollNext(api.canScrollNext())
    }, [])

    const scrollPrev = React.useCallback(() => {
      api?.scrollPrev()
    }, [api])

    const scrollNext = React.useCallback(() => {
      api?.scrollNext()
    }, [api])

    const handleKeyDown = React.useCallback(
      (event: React.KeyboardEvent<HTMLDivElement>) => {
        if (event.key === "ArrowLeft") {
          event.preventDefault()
          scrollPrev()
        } else if (event.key === "ArrowRight") {
          event.preventDefault()
          scrollNext()
        }
      },
      [scrollPrev, scrollNext]
    )

    React.useEffect(() => {
      if (!api || !setApi) {
        return
      }

      setApi(api)
    }, [api, setApi])

    React.useEffect(() => {
      if (!api) {
        return
      }

      onSelect(api)
      api.on("reInit", onSelect)
      api.on("select", onSelect)

      return () => {
        api?.off("select", onSelect)
      }
    }, [api, onSelect])

    return (
      <CarouselContext.Provider
        value={{
          carouselRef,
          api: api,
          opts,
          orientation:
            orientation || (opts?.axis === "y" ? "vertical" : "horizontal"),
          scrollPrev,
          scrollNext,
          canScrollPrev,
          canScrollNext,
        }}
      >
        <div
          ref={ref}
          onKeyDownCapture={handleKeyDown}
          className={cn("relative", className)}
          role="region"
          aria-roledescription="carousel"
          {...props}
        >
          {children}
        </div>
      </CarouselContext.Provider>
    )
  }
)
Carousel.displayName = "Carousel"

const CarouselContent = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { carouselRef, orientation } = useCarousel()

  return (
    <div ref={carouselRef} className="overflow-hidden">
      <div
        ref={ref}
        className={cn(
          "flex",
          orientation === "horizontal" ? "-ml-4" : "-mt-4 flex-col",
          className
        )}
        {...props}
      />
    </div>
  )
})
CarouselContent.displayName = "CarouselContent"

const CarouselItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const { orientation } = useCarousel()

  return (
    <div
      ref={ref}
      role="group"
      aria-roledescription="slide"
      className={cn(
        "min-w-0 shrink-0 grow-0 basis-full",
        orientation === "horizontal" ? "pl-4" : "pt-4",
        className
      )}
      {...props}
    />
  )
})
CarouselItem.displayName = "CarouselItem"

const CarouselPrevious = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollPrev, canScrollPrev } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute  h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-left-12 top-1/2 -translate-y-1/2"
          : "-top-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollPrev}
      onClick={scrollPrev}
      {...props}
    >
      <ArrowLeft className="h-4 w-4" />
      <span className="sr-only">Previous slide</span>
    </Button>
  )
})
CarouselPrevious.displayName = "CarouselPrevious"

const CarouselNext = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<typeof Button>
>(({ className, variant = "outline", size = "icon", ...props }, ref) => {
  const { orientation, scrollNext, canScrollNext } = useCarousel()

  return (
    <Button
      ref={ref}
      variant={variant}
      size={size}
      className={cn(
        "absolute h-8 w-8 rounded-full",
        orientation === "horizontal"
          ? "-right-12 top-1/2 -translate-y-1/2"
          : "-bottom-12 left-1/2 -translate-x-1/2 rotate-90",
        className
      )}
      disabled={!canScrollNext}
      onClick={scrollNext}
      {...props}
    >
      <ArrowRight className="h-4 w-4" />
      <span className="sr-only">Next slide</span>
    </Button>
  )
})
CarouselNext.displayName = "CarouselNext"

export {
  type CarouselApi,
  Carousel,
  CarouselContent,
  CarouselItem,
  CarouselPrevious,
  CarouselNext,
}

================
File: components/ui/chart.tsx
================
"use client"

import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = { light: "", dark: ".dark" } as const

export type ChartConfig = {
  [k in string]: {
    label?: React.ReactNode
    icon?: React.ComponentType
  } & (
    | { color?: string; theme?: never }
    | { color?: never; theme: Record<keyof typeof THEMES, string> }
  )
}

type ChartContextProps = {
  config: ChartConfig
}

const ChartContext = React.createContext<ChartContextProps | null>(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

const ChartContainer = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    config: ChartConfig
    children: React.ComponentProps<
      typeof RechartsPrimitive.ResponsiveContainer
    >["children"]
  }
>(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}
      >
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  )
})
ChartContainer.displayName = "Chart"

const ChartStyle = ({ id, config }: { id: string; config: ChartConfig }) => {
  const colorConfig = Object.entries(config).filter(
    ([_, config]) => config.theme || config.color
  )

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(
            ([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
  .map(([key, itemConfig]) => {
    const color =
      itemConfig.theme?.[theme as keyof typeof itemConfig.theme] ||
      itemConfig.color
    return color ? `  --color-${key}: ${color};` : null
  })
  .join("\n")}
}
`
          )
          .join("\n"),
      }}
    />
  )
}

const ChartTooltip = RechartsPrimitive.Tooltip

const ChartTooltipContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<typeof RechartsPrimitive.Tooltip> &
    React.ComponentProps<"div"> & {
      hideLabel?: boolean
      hideIndicator?: boolean
      indicator?: "line" | "dot" | "dashed"
      nameKey?: string
      labelKey?: string
    }
>(
  (
    {
      active,
      payload,
      className,
      indicator = "dot",
      hideLabel = false,
      hideIndicator = false,
      label,
      labelFormatter,
      labelClassName,
      formatter,
      color,
      nameKey,
      labelKey,
    },
    ref
  ) => {
    const { config } = useChart()

    const tooltipLabel = React.useMemo(() => {
      if (hideLabel || !payload?.length) {
        return null
      }

      const [item] = payload
      const key = `${labelKey || item.dataKey || item.name || "value"}`
      const itemConfig = getPayloadConfigFromPayload(config, item, key)
      const value =
        !labelKey && typeof label === "string"
          ? config[label as keyof typeof config]?.label || label
          : itemConfig?.label

      if (labelFormatter) {
        return (
          <div className={cn("font-medium", labelClassName)}>
            {labelFormatter(value, payload)}
          </div>
        )
      }

      if (!value) {
        return null
      }

      return <div className={cn("font-medium", labelClassName)}>{value}</div>
    }, [
      label,
      labelFormatter,
      payload,
      hideLabel,
      labelClassName,
      config,
      labelKey,
    ])

    if (!active || !payload?.length) {
      return null
    }

    const nestLabel = payload.length === 1 && indicator !== "dot"

    return (
      <div
        ref={ref}
        className={cn(
          "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
          className
        )}
      >
        {!nestLabel ? tooltipLabel : null}
        <div className="grid gap-1.5">
          {payload.map((item, index) => {
            const key = `${nameKey || item.name || item.dataKey || "value"}`
            const itemConfig = getPayloadConfigFromPayload(config, item, key)
            const indicatorColor = color || item.payload.fill || item.color

            return (
              <div
                key={item.dataKey}
                className={cn(
                  "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                  indicator === "dot" && "items-center"
                )}
              >
                {formatter && item?.value !== undefined && item.name ? (
                  formatter(item.value, item.name, item, index, item.payload)
                ) : (
                  <>
                    {itemConfig?.icon ? (
                      <itemConfig.icon />
                    ) : (
                      !hideIndicator && (
                        <div
                          className={cn(
                            "shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]",
                            {
                              "h-2.5 w-2.5": indicator === "dot",
                              "w-1": indicator === "line",
                              "w-0 border-[1.5px] border-dashed bg-transparent":
                                indicator === "dashed",
                              "my-0.5": nestLabel && indicator === "dashed",
                            }
                          )}
                          style={
                            {
                              "--color-bg": indicatorColor,
                              "--color-border": indicatorColor,
                            } as React.CSSProperties
                          }
                        />
                      )
                    )}
                    <div
                      className={cn(
                        "flex flex-1 justify-between leading-none",
                        nestLabel ? "items-end" : "items-center"
                      )}
                    >
                      <div className="grid gap-1.5">
                        {nestLabel ? tooltipLabel : null}
                        <span className="text-muted-foreground">
                          {itemConfig?.label || item.name}
                        </span>
                      </div>
                      {item.value && (
                        <span className="font-mono font-medium tabular-nums text-foreground">
                          {item.value.toLocaleString()}
                        </span>
                      )}
                    </div>
                  </>
                )}
              </div>
            )
          })}
        </div>
      </div>
    )
  }
)
ChartTooltipContent.displayName = "ChartTooltip"

const ChartLegend = RechartsPrimitive.Legend

const ChartLegendContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> &
    Pick<RechartsPrimitive.LegendProps, "payload" | "verticalAlign"> & {
      hideIcon?: boolean
      nameKey?: string
    }
>(
  (
    { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
    ref
  ) => {
    const { config } = useChart()

    if (!payload?.length) {
      return null
    }

    return (
      <div
        ref={ref}
        className={cn(
          "flex items-center justify-center gap-4",
          verticalAlign === "top" ? "pb-3" : "pt-3",
          className
        )}
      >
        {payload.map((item) => {
          const key = `${nameKey || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)

          return (
            <div
              key={item.value}
              className={cn(
                "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
              )}
            >
              {itemConfig?.icon && !hideIcon ? (
                <itemConfig.icon />
              ) : (
                <div
                  className="h-2 w-2 shrink-0 rounded-[2px]"
                  style={{
                    backgroundColor: item.color,
                  }}
                />
              )}
              {itemConfig?.label}
            </div>
          )
        })}
      </div>
    )
  }
)
ChartLegendContent.displayName = "ChartLegend"

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config: ChartConfig,
  payload: unknown,
  key: string
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey: string = key

  if (
    key in payload &&
    typeof payload[key as keyof typeof payload] === "string"
  ) {
    configLabelKey = payload[key as keyof typeof payload] as string
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key as keyof typeof payloadPayload] === "string"
  ) {
    configLabelKey = payloadPayload[
      key as keyof typeof payloadPayload
    ] as string
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key as keyof typeof config]
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}

================
File: components/ui/checkbox.tsx
================
"use client"

import * as React from "react"
import * as CheckboxPrimitive from "@radix-ui/react-checkbox"
import { Check } from "lucide-react"

import { cn } from "@/lib/utils"

const Checkbox = React.forwardRef<
  React.ElementRef<typeof CheckboxPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof CheckboxPrimitive.Root>
>(({ className, ...props }, ref) => (
  <CheckboxPrimitive.Root
    ref={ref}
    className={cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    )}
    {...props}
  >
    <CheckboxPrimitive.Indicator
      className={cn("flex items-center justify-center text-current")}
    >
      <Check className="h-4 w-4" />
    </CheckboxPrimitive.Indicator>
  </CheckboxPrimitive.Root>
))
Checkbox.displayName = CheckboxPrimitive.Root.displayName

export { Checkbox }

================
File: components/ui/collapsible.tsx
================
"use client"

import * as CollapsiblePrimitive from "@radix-ui/react-collapsible"

const Collapsible = CollapsiblePrimitive.Root

const CollapsibleTrigger = CollapsiblePrimitive.CollapsibleTrigger

const CollapsibleContent = CollapsiblePrimitive.CollapsibleContent

export { Collapsible, CollapsibleTrigger, CollapsibleContent }

================
File: components/ui/command.tsx
================
"use client"

import * as React from "react"
import { type DialogProps } from "@radix-ui/react-dialog"
import { Command as CommandPrimitive } from "cmdk"
import { Search } from "lucide-react"

import { cn } from "@/lib/utils"
import { Dialog, DialogContent } from "@/components/ui/dialog"

const Command = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive>
>(({ className, ...props }, ref) => (
  <CommandPrimitive
    ref={ref}
    className={cn(
      "flex h-full w-full flex-col overflow-hidden rounded-md bg-popover text-popover-foreground",
      className
    )}
    {...props}
  />
))
Command.displayName = CommandPrimitive.displayName

const CommandDialog = ({ children, ...props }: DialogProps) => {
  return (
    <Dialog {...props}>
      <DialogContent className="overflow-hidden p-0 shadow-lg">
        <Command className="[&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-group]]:px-2 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

const CommandInput = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Input>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Input>
>(({ className, ...props }, ref) => (
  <div className="flex items-center border-b px-3" cmdk-input-wrapper="">
    <Search className="mr-2 h-4 w-4 shrink-0 opacity-50" />
    <CommandPrimitive.Input
      ref={ref}
      className={cn(
        "flex h-11 w-full rounded-md bg-transparent py-3 text-sm outline-none placeholder:text-muted-foreground disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    />
  </div>
))

CommandInput.displayName = CommandPrimitive.Input.displayName

const CommandList = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.List>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.List
    ref={ref}
    className={cn("max-h-[300px] overflow-y-auto overflow-x-hidden", className)}
    {...props}
  />
))

CommandList.displayName = CommandPrimitive.List.displayName

const CommandEmpty = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Empty>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Empty>
>((props, ref) => (
  <CommandPrimitive.Empty
    ref={ref}
    className="py-6 text-center text-sm"
    {...props}
  />
))

CommandEmpty.displayName = CommandPrimitive.Empty.displayName

const CommandGroup = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Group>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Group>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Group
    ref={ref}
    className={cn(
      "overflow-hidden p-1 text-foreground [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group-heading]]:text-muted-foreground",
      className
    )}
    {...props}
  />
))

CommandGroup.displayName = CommandPrimitive.Group.displayName

const CommandSeparator = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 h-px bg-border", className)}
    {...props}
  />
))
CommandSeparator.displayName = CommandPrimitive.Separator.displayName

const CommandItem = React.forwardRef<
  React.ElementRef<typeof CommandPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof CommandPrimitive.Item>
>(({ className, ...props }, ref) => (
  <CommandPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none data-[disabled=true]:pointer-events-none data-[selected='true']:bg-accent data-[selected=true]:text-accent-foreground data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      className
    )}
    {...props}
  />
))

CommandItem.displayName = CommandPrimitive.Item.displayName

const CommandShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
CommandShortcut.displayName = "CommandShortcut"

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}

================
File: components/ui/context-menu.tsx
================
"use client"

import * as React from "react"
import * as ContextMenuPrimitive from "@radix-ui/react-context-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const ContextMenu = ContextMenuPrimitive.Root

const ContextMenuTrigger = ContextMenuPrimitive.Trigger

const ContextMenuGroup = ContextMenuPrimitive.Group

const ContextMenuPortal = ContextMenuPrimitive.Portal

const ContextMenuSub = ContextMenuPrimitive.Sub

const ContextMenuRadioGroup = ContextMenuPrimitive.RadioGroup

const ContextMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <ContextMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </ContextMenuPrimitive.SubTrigger>
))
ContextMenuSubTrigger.displayName = ContextMenuPrimitive.SubTrigger.displayName

const ContextMenuSubContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
ContextMenuSubContent.displayName = ContextMenuPrimitive.SubContent.displayName

const ContextMenuContent = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Portal>
    <ContextMenuPrimitive.Content
      ref={ref}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md animate-in fade-in-80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </ContextMenuPrimitive.Portal>
))
ContextMenuContent.displayName = ContextMenuPrimitive.Content.displayName

const ContextMenuItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuItem.displayName = ContextMenuPrimitive.Item.displayName

const ContextMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <ContextMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.CheckboxItem>
))
ContextMenuCheckboxItem.displayName =
  ContextMenuPrimitive.CheckboxItem.displayName

const ContextMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <ContextMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <ContextMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </ContextMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </ContextMenuPrimitive.RadioItem>
))
ContextMenuRadioItem.displayName = ContextMenuPrimitive.RadioItem.displayName

const ContextMenuLabel = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <ContextMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold text-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
ContextMenuLabel.displayName = ContextMenuPrimitive.Label.displayName

const ContextMenuSeparator = React.forwardRef<
  React.ElementRef<typeof ContextMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof ContextMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <ContextMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-border", className)}
    {...props}
  />
))
ContextMenuSeparator.displayName = ContextMenuPrimitive.Separator.displayName

const ContextMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
ContextMenuShortcut.displayName = "ContextMenuShortcut"

export {
  ContextMenu,
  ContextMenuTrigger,
  ContextMenuContent,
  ContextMenuItem,
  ContextMenuCheckboxItem,
  ContextMenuRadioItem,
  ContextMenuLabel,
  ContextMenuSeparator,
  ContextMenuShortcut,
  ContextMenuGroup,
  ContextMenuPortal,
  ContextMenuSub,
  ContextMenuSubContent,
  ContextMenuSubTrigger,
  ContextMenuRadioGroup,
}

================
File: components/ui/dialog.tsx
================
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
      <DialogPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </DialogPrimitive.Close>
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

================
File: components/ui/drawer.tsx
================
"use client"

import * as React from "react"
import { Drawer as DrawerPrimitive } from "vaul"

import { cn } from "@/lib/utils"

const Drawer = ({
  shouldScaleBackground = true,
  ...props
}: React.ComponentProps<typeof DrawerPrimitive.Root>) => (
  <DrawerPrimitive.Root
    shouldScaleBackground={shouldScaleBackground}
    {...props}
  />
)
Drawer.displayName = "Drawer"

const DrawerTrigger = DrawerPrimitive.Trigger

const DrawerPortal = DrawerPrimitive.Portal

const DrawerClose = DrawerPrimitive.Close

const DrawerOverlay = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Overlay
    ref={ref}
    className={cn("fixed inset-0 z-50 bg-black/80", className)}
    {...props}
  />
))
DrawerOverlay.displayName = DrawerPrimitive.Overlay.displayName

const DrawerContent = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DrawerPortal>
    <DrawerOverlay />
    <DrawerPrimitive.Content
      ref={ref}
      className={cn(
        "fixed inset-x-0 bottom-0 z-50 mt-24 flex h-auto flex-col rounded-t-[10px] border bg-background",
        className
      )}
      {...props}
    >
      <div className="mx-auto mt-4 h-2 w-[100px] rounded-full bg-muted" />
      {children}
    </DrawerPrimitive.Content>
  </DrawerPortal>
))
DrawerContent.displayName = "DrawerContent"

const DrawerHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("grid gap-1.5 p-4 text-center sm:text-left", className)}
    {...props}
  />
)
DrawerHeader.displayName = "DrawerHeader"

const DrawerFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn("mt-auto flex flex-col gap-2 p-4", className)}
    {...props}
  />
)
DrawerFooter.displayName = "DrawerFooter"

const DrawerTitle = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DrawerTitle.displayName = DrawerPrimitive.Title.displayName

const DrawerDescription = React.forwardRef<
  React.ElementRef<typeof DrawerPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DrawerPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DrawerPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DrawerDescription.displayName = DrawerPrimitive.Description.displayName

export {
  Drawer,
  DrawerPortal,
  DrawerOverlay,
  DrawerTrigger,
  DrawerClose,
  DrawerContent,
  DrawerHeader,
  DrawerFooter,
  DrawerTitle,
  DrawerDescription,
}

================
File: components/ui/dropdown-menu.tsx
================
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const DropdownMenu = DropdownMenuPrimitive.Root

const DropdownMenuTrigger = DropdownMenuPrimitive.Trigger

const DropdownMenuGroup = DropdownMenuPrimitive.Group

const DropdownMenuPortal = DropdownMenuPrimitive.Portal

const DropdownMenuSub = DropdownMenuPrimitive.Sub

const DropdownMenuRadioGroup = DropdownMenuPrimitive.RadioGroup

const DropdownMenuSubTrigger = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <DropdownMenuPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default gap-2 select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent data-[state=open]:bg-accent [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto" />
  </DropdownMenuPrimitive.SubTrigger>
))
DropdownMenuSubTrigger.displayName =
  DropdownMenuPrimitive.SubTrigger.displayName

const DropdownMenuSubContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
DropdownMenuSubContent.displayName =
  DropdownMenuPrimitive.SubContent.displayName

const DropdownMenuContent = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <DropdownMenuPrimitive.Portal>
    <DropdownMenuPrimitive.Content
      ref={ref}
      sideOffset={sideOffset}
      className={cn(
        "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </DropdownMenuPrimitive.Portal>
))
DropdownMenuContent.displayName = DropdownMenuPrimitive.Content.displayName

const DropdownMenuItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuItem.displayName = DropdownMenuPrimitive.Item.displayName

const DropdownMenuCheckboxItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <DropdownMenuPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.CheckboxItem>
))
DropdownMenuCheckboxItem.displayName =
  DropdownMenuPrimitive.CheckboxItem.displayName

const DropdownMenuRadioItem = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <DropdownMenuPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none transition-colors focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <DropdownMenuPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </DropdownMenuPrimitive.ItemIndicator>
    </span>
    {children}
  </DropdownMenuPrimitive.RadioItem>
))
DropdownMenuRadioItem.displayName = DropdownMenuPrimitive.RadioItem.displayName

const DropdownMenuLabel = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <DropdownMenuPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
DropdownMenuLabel.displayName = DropdownMenuPrimitive.Label.displayName

const DropdownMenuSeparator = React.forwardRef<
  React.ElementRef<typeof DropdownMenuPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof DropdownMenuPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <DropdownMenuPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
DropdownMenuSeparator.displayName = DropdownMenuPrimitive.Separator.displayName

const DropdownMenuShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn("ml-auto text-xs tracking-widest opacity-60", className)}
      {...props}
    />
  )
}
DropdownMenuShortcut.displayName = "DropdownMenuShortcut"

export {
  DropdownMenu,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuGroup,
  DropdownMenuPortal,
  DropdownMenuSub,
  DropdownMenuSubContent,
  DropdownMenuSubTrigger,
  DropdownMenuRadioGroup,
}

================
File: components/ui/form.tsx
================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { Slot } from "@radix-ui/react-slot"
import {
  Controller,
  ControllerProps,
  FieldPath,
  FieldValues,
  FormProvider,
  useFormContext,
} from "react-hook-form"

import { cn } from "@/lib/utils"
import { Label } from "@/components/ui/label"

const Form = FormProvider

type FormFieldContextValue<
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
> = {
  name: TName
}

const FormFieldContext = React.createContext<FormFieldContextValue>(
  {} as FormFieldContextValue
)

const FormField = <
  TFieldValues extends FieldValues = FieldValues,
  TName extends FieldPath<TFieldValues> = FieldPath<TFieldValues>
>({
  ...props
}: ControllerProps<TFieldValues, TName>) => {
  return (
    <FormFieldContext.Provider value={{ name: props.name }}>
      <Controller {...props} />
    </FormFieldContext.Provider>
  )
}

const useFormField = () => {
  const fieldContext = React.useContext(FormFieldContext)
  const itemContext = React.useContext(FormItemContext)
  const { getFieldState, formState } = useFormContext()

  const fieldState = getFieldState(fieldContext.name, formState)

  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>")
  }

  const { id } = itemContext

  return {
    id,
    name: fieldContext.name,
    formItemId: `${id}-form-item`,
    formDescriptionId: `${id}-form-item-description`,
    formMessageId: `${id}-form-item-message`,
    ...fieldState,
  }
}

type FormItemContextValue = {
  id: string
}

const FormItemContext = React.createContext<FormItemContextValue>(
  {} as FormItemContextValue
)

const FormItem = React.forwardRef<
  HTMLDivElement,
  React.HTMLAttributes<HTMLDivElement>
>(({ className, ...props }, ref) => {
  const id = React.useId()

  return (
    <FormItemContext.Provider value={{ id }}>
      <div ref={ref} className={cn("space-y-2", className)} {...props} />
    </FormItemContext.Provider>
  )
})
FormItem.displayName = "FormItem"

const FormLabel = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root>
>(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField()

  return (
    <Label
      ref={ref}
      className={cn(error && "text-destructive", className)}
      htmlFor={formItemId}
      {...props}
    />
  )
})
FormLabel.displayName = "FormLabel"

const FormControl = React.forwardRef<
  React.ElementRef<typeof Slot>,
  React.ComponentPropsWithoutRef<typeof Slot>
>(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField()

  return (
    <Slot
      ref={ref}
      id={formItemId}
      aria-describedby={
        !error
          ? `${formDescriptionId}`
          : `${formDescriptionId} ${formMessageId}`
      }
      aria-invalid={!!error}
      {...props}
    />
  )
})
FormControl.displayName = "FormControl"

const FormDescription = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField()

  return (
    <p
      ref={ref}
      id={formDescriptionId}
      className={cn("text-sm text-muted-foreground", className)}
      {...props}
    />
  )
})
FormDescription.displayName = "FormDescription"

const FormMessage = React.forwardRef<
  HTMLParagraphElement,
  React.HTMLAttributes<HTMLParagraphElement>
>(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField()
  const body = error ? String(error?.message) : children

  if (!body) {
    return null
  }

  return (
    <p
      ref={ref}
      id={formMessageId}
      className={cn("text-sm font-medium text-destructive", className)}
      {...props}
    >
      {body}
    </p>
  )
})
FormMessage.displayName = "FormMessage"

export {
  useFormField,
  Form,
  FormItem,
  FormLabel,
  FormControl,
  FormDescription,
  FormMessage,
  FormField,
}

================
File: components/ui/hover-card.tsx
================
"use client"

import * as React from "react"
import * as HoverCardPrimitive from "@radix-ui/react-hover-card"

import { cn } from "@/lib/utils"

const HoverCard = HoverCardPrimitive.Root

const HoverCardTrigger = HoverCardPrimitive.Trigger

const HoverCardContent = React.forwardRef<
  React.ElementRef<typeof HoverCardPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof HoverCardPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <HoverCardPrimitive.Content
    ref={ref}
    align={align}
    sideOffset={sideOffset}
    className={cn(
      "z-50 w-64 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
HoverCardContent.displayName = HoverCardPrimitive.Content.displayName

export { HoverCard, HoverCardTrigger, HoverCardContent }

================
File: components/ui/input-otp.tsx
================
"use client"

import * as React from "react"
import { OTPInput, OTPInputContext } from "input-otp"
import { Dot } from "lucide-react"

import { cn } from "@/lib/utils"

const InputOTP = React.forwardRef<
  React.ElementRef<typeof OTPInput>,
  React.ComponentPropsWithoutRef<typeof OTPInput>
>(({ className, containerClassName, ...props }, ref) => (
  <OTPInput
    ref={ref}
    containerClassName={cn(
      "flex items-center gap-2 has-[:disabled]:opacity-50",
      containerClassName
    )}
    className={cn("disabled:cursor-not-allowed", className)}
    {...props}
  />
))
InputOTP.displayName = "InputOTP"

const InputOTPGroup = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("flex items-center", className)} {...props} />
))
InputOTPGroup.displayName = "InputOTPGroup"

const InputOTPSlot = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div"> & { index: number }
>(({ index, className, ...props }, ref) => {
  const inputOTPContext = React.useContext(OTPInputContext)
  const { char, hasFakeCaret, isActive } = inputOTPContext.slots[index]

  return (
    <div
      ref={ref}
      className={cn(
        "relative flex h-10 w-10 items-center justify-center border-y border-r border-input text-sm transition-all first:rounded-l-md first:border-l last:rounded-r-md",
        isActive && "z-10 ring-2 ring-ring ring-offset-background",
        className
      )}
      {...props}
    >
      {char}
      {hasFakeCaret && (
        <div className="pointer-events-none absolute inset-0 flex items-center justify-center">
          <div className="h-4 w-px animate-caret-blink bg-foreground duration-1000" />
        </div>
      )}
    </div>
  )
})
InputOTPSlot.displayName = "InputOTPSlot"

const InputOTPSeparator = React.forwardRef<
  React.ElementRef<"div">,
  React.ComponentPropsWithoutRef<"div">
>(({ ...props }, ref) => (
  <div ref={ref} role="separator" {...props}>
    <Dot />
  </div>
))
InputOTPSeparator.displayName = "InputOTPSeparator"

export { InputOTP, InputOTPGroup, InputOTPSlot, InputOTPSeparator }

================
File: components/ui/input.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef<HTMLInputElement, React.ComponentProps<"input">>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Input.displayName = "Input"

export { Input }

================
File: components/ui/label.tsx
================
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef<
  React.ElementRef<typeof LabelPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof LabelPrimitive.Root> &
    VariantProps<typeof labelVariants>
>(({ className, ...props }, ref) => (
  <LabelPrimitive.Root
    ref={ref}
    className={cn(labelVariants(), className)}
    {...props}
  />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }

================
File: components/ui/menubar.tsx
================
"use client"

import * as React from "react"
import * as MenubarPrimitive from "@radix-ui/react-menubar"
import { Check, ChevronRight, Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const MenubarMenu = MenubarPrimitive.Menu

const MenubarGroup = MenubarPrimitive.Group

const MenubarPortal = MenubarPrimitive.Portal

const MenubarSub = MenubarPrimitive.Sub

const MenubarRadioGroup = MenubarPrimitive.RadioGroup

const Menubar = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Root
    ref={ref}
    className={cn(
      "flex h-10 items-center space-x-1 rounded-md border bg-background p-1",
      className
    )}
    {...props}
  />
))
Menubar.displayName = MenubarPrimitive.Root.displayName

const MenubarTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-3 py-1.5 text-sm font-medium outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      className
    )}
    {...props}
  />
))
MenubarTrigger.displayName = MenubarPrimitive.Trigger.displayName

const MenubarSubTrigger = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubTrigger>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubTrigger> & {
    inset?: boolean
  }
>(({ className, inset, children, ...props }, ref) => (
  <MenubarPrimitive.SubTrigger
    ref={ref}
    className={cn(
      "flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground",
      inset && "pl-8",
      className
    )}
    {...props}
  >
    {children}
    <ChevronRight className="ml-auto h-4 w-4" />
  </MenubarPrimitive.SubTrigger>
))
MenubarSubTrigger.displayName = MenubarPrimitive.SubTrigger.displayName

const MenubarSubContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.SubContent>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.SubContent>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.SubContent
    ref={ref}
    className={cn(
      "z-50 min-w-[8rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
MenubarSubContent.displayName = MenubarPrimitive.SubContent.displayName

const MenubarContent = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Content>
>(
  (
    { className, align = "start", alignOffset = -4, sideOffset = 8, ...props },
    ref
  ) => (
    <MenubarPrimitive.Portal>
      <MenubarPrimitive.Content
        ref={ref}
        align={align}
        alignOffset={alignOffset}
        sideOffset={sideOffset}
        className={cn(
          "z-50 min-w-[12rem] overflow-hidden rounded-md border bg-popover p-1 text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
          className
        )}
        {...props}
      />
    </MenubarPrimitive.Portal>
  )
)
MenubarContent.displayName = MenubarPrimitive.Content.displayName

const MenubarItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Item> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm px-2 py-1.5 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarItem.displayName = MenubarPrimitive.Item.displayName

const MenubarCheckboxItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.CheckboxItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.CheckboxItem>
>(({ className, children, checked, ...props }, ref) => (
  <MenubarPrimitive.CheckboxItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    checked={checked}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.CheckboxItem>
))
MenubarCheckboxItem.displayName = MenubarPrimitive.CheckboxItem.displayName

const MenubarRadioItem = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.RadioItem>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.RadioItem>
>(({ className, children, ...props }, ref) => (
  <MenubarPrimitive.RadioItem
    ref={ref}
    className={cn(
      "relative flex cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <MenubarPrimitive.ItemIndicator>
        <Circle className="h-2 w-2 fill-current" />
      </MenubarPrimitive.ItemIndicator>
    </span>
    {children}
  </MenubarPrimitive.RadioItem>
))
MenubarRadioItem.displayName = MenubarPrimitive.RadioItem.displayName

const MenubarLabel = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Label> & {
    inset?: boolean
  }
>(({ className, inset, ...props }, ref) => (
  <MenubarPrimitive.Label
    ref={ref}
    className={cn(
      "px-2 py-1.5 text-sm font-semibold",
      inset && "pl-8",
      className
    )}
    {...props}
  />
))
MenubarLabel.displayName = MenubarPrimitive.Label.displayName

const MenubarSeparator = React.forwardRef<
  React.ElementRef<typeof MenubarPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof MenubarPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <MenubarPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
MenubarSeparator.displayName = MenubarPrimitive.Separator.displayName

const MenubarShortcut = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLSpanElement>) => {
  return (
    <span
      className={cn(
        "ml-auto text-xs tracking-widest text-muted-foreground",
        className
      )}
      {...props}
    />
  )
}
MenubarShortcut.displayname = "MenubarShortcut"

export {
  Menubar,
  MenubarMenu,
  MenubarTrigger,
  MenubarContent,
  MenubarItem,
  MenubarSeparator,
  MenubarLabel,
  MenubarCheckboxItem,
  MenubarRadioGroup,
  MenubarRadioItem,
  MenubarPortal,
  MenubarSubContent,
  MenubarSubTrigger,
  MenubarGroup,
  MenubarSub,
  MenubarShortcut,
}

================
File: components/ui/navigation-menu.tsx
================
import * as React from "react"
import * as NavigationMenuPrimitive from "@radix-ui/react-navigation-menu"
import { cva } from "class-variance-authority"
import { ChevronDown } from "lucide-react"

import { cn } from "@/lib/utils"

const NavigationMenu = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Root
    ref={ref}
    className={cn(
      "relative z-10 flex max-w-max flex-1 items-center justify-center",
      className
    )}
    {...props}
  >
    {children}
    <NavigationMenuViewport />
  </NavigationMenuPrimitive.Root>
))
NavigationMenu.displayName = NavigationMenuPrimitive.Root.displayName

const NavigationMenuList = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.List>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.List
    ref={ref}
    className={cn(
      "group flex flex-1 list-none items-center justify-center space-x-1",
      className
    )}
    {...props}
  />
))
NavigationMenuList.displayName = NavigationMenuPrimitive.List.displayName

const NavigationMenuItem = NavigationMenuPrimitive.Item

const navigationMenuTriggerStyle = cva(
  "group inline-flex h-10 w-max items-center justify-center rounded-md bg-background px-4 py-2 text-sm font-medium transition-colors hover:bg-accent hover:text-accent-foreground focus:bg-accent focus:text-accent-foreground focus:outline-none disabled:pointer-events-none disabled:opacity-50 data-[active]:bg-accent/50 data-[state=open]:bg-accent/50"
)

const NavigationMenuTrigger = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <NavigationMenuPrimitive.Trigger
    ref={ref}
    className={cn(navigationMenuTriggerStyle(), "group", className)}
    {...props}
  >
    {children}{" "}
    <ChevronDown
      className="relative top-[1px] ml-1 h-3 w-3 transition duration-200 group-data-[state=open]:rotate-180"
      aria-hidden="true"
    />
  </NavigationMenuPrimitive.Trigger>
))
NavigationMenuTrigger.displayName = NavigationMenuPrimitive.Trigger.displayName

const NavigationMenuContent = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Content>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Content
    ref={ref}
    className={cn(
      "left-0 top-0 w-full data-[motion^=from-]:animate-in data-[motion^=to-]:animate-out data-[motion^=from-]:fade-in data-[motion^=to-]:fade-out data-[motion=from-end]:slide-in-from-right-52 data-[motion=from-start]:slide-in-from-left-52 data-[motion=to-end]:slide-out-to-right-52 data-[motion=to-start]:slide-out-to-left-52 md:absolute md:w-auto ",
      className
    )}
    {...props}
  />
))
NavigationMenuContent.displayName = NavigationMenuPrimitive.Content.displayName

const NavigationMenuLink = NavigationMenuPrimitive.Link

const NavigationMenuViewport = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Viewport>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Viewport>
>(({ className, ...props }, ref) => (
  <div className={cn("absolute left-0 top-full flex justify-center")}>
    <NavigationMenuPrimitive.Viewport
      className={cn(
        "origin-top-center relative mt-1.5 h-[var(--radix-navigation-menu-viewport-height)] w-full overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-lg data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-90 md:w-[var(--radix-navigation-menu-viewport-width)]",
        className
      )}
      ref={ref}
      {...props}
    />
  </div>
))
NavigationMenuViewport.displayName =
  NavigationMenuPrimitive.Viewport.displayName

const NavigationMenuIndicator = React.forwardRef<
  React.ElementRef<typeof NavigationMenuPrimitive.Indicator>,
  React.ComponentPropsWithoutRef<typeof NavigationMenuPrimitive.Indicator>
>(({ className, ...props }, ref) => (
  <NavigationMenuPrimitive.Indicator
    ref={ref}
    className={cn(
      "top-full z-[1] flex h-1.5 items-end justify-center overflow-hidden data-[state=visible]:animate-in data-[state=hidden]:animate-out data-[state=hidden]:fade-out data-[state=visible]:fade-in",
      className
    )}
    {...props}
  >
    <div className="relative top-[60%] h-2 w-2 rotate-45 rounded-tl-sm bg-border shadow-md" />
  </NavigationMenuPrimitive.Indicator>
))
NavigationMenuIndicator.displayName =
  NavigationMenuPrimitive.Indicator.displayName

export {
  navigationMenuTriggerStyle,
  NavigationMenu,
  NavigationMenuList,
  NavigationMenuItem,
  NavigationMenuContent,
  NavigationMenuTrigger,
  NavigationMenuLink,
  NavigationMenuIndicator,
  NavigationMenuViewport,
}

================
File: components/ui/pagination.tsx
================
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
}

================
File: components/ui/popover.tsx
================
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

const Popover = PopoverPrimitive.Root

const PopoverTrigger = PopoverPrimitive.Trigger

const PopoverContent = React.forwardRef<
  React.ElementRef<typeof PopoverPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof PopoverPrimitive.Content>
>(({ className, align = "center", sideOffset = 4, ...props }, ref) => (
  <PopoverPrimitive.Portal>
    <PopoverPrimitive.Content
      ref={ref}
      align={align}
      sideOffset={sideOffset}
      className={cn(
        "z-50 w-72 rounded-md border bg-popover p-4 text-popover-foreground shadow-md outline-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        className
      )}
      {...props}
    />
  </PopoverPrimitive.Portal>
))
PopoverContent.displayName = PopoverPrimitive.Content.displayName

export { Popover, PopoverTrigger, PopoverContent }

================
File: components/ui/progress.tsx
================
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }

================
File: components/ui/radio-group.tsx
================
"use client"

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Root>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Root
      className={cn("grid gap-2", className)}
      {...props}
      ref={ref}
    />
  )
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef<
  React.ElementRef<typeof RadioGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof RadioGroupPrimitive.Item>
>(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  )
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }

================
File: components/ui/resizable.tsx
================
"use client"

import { GripVertical } from "lucide-react"
import * as ResizablePrimitive from "react-resizable-panels"

import { cn } from "@/lib/utils"

const ResizablePanelGroup = ({
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelGroup>) => (
  <ResizablePrimitive.PanelGroup
    className={cn(
      "flex h-full w-full data-[panel-group-direction=vertical]:flex-col",
      className
    )}
    {...props}
  />
)

const ResizablePanel = ResizablePrimitive.Panel

const ResizableHandle = ({
  withHandle,
  className,
  ...props
}: React.ComponentProps<typeof ResizablePrimitive.PanelResizeHandle> & {
  withHandle?: boolean
}) => (
  <ResizablePrimitive.PanelResizeHandle
    className={cn(
      "relative flex w-px items-center justify-center bg-border after:absolute after:inset-y-0 after:left-1/2 after:w-1 after:-translate-x-1/2 focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring focus-visible:ring-offset-1 data-[panel-group-direction=vertical]:h-px data-[panel-group-direction=vertical]:w-full data-[panel-group-direction=vertical]:after:left-0 data-[panel-group-direction=vertical]:after:h-1 data-[panel-group-direction=vertical]:after:w-full data-[panel-group-direction=vertical]:after:-translate-y-1/2 data-[panel-group-direction=vertical]:after:translate-x-0 [&[data-panel-group-direction=vertical]>div]:rotate-90",
      className
    )}
    {...props}
  >
    {withHandle && (
      <div className="z-10 flex h-4 w-3 items-center justify-center rounded-sm border bg-border">
        <GripVertical className="h-2.5 w-2.5" />
      </div>
    )}
  </ResizablePrimitive.PanelResizeHandle>
)

export { ResizablePanelGroup, ResizablePanel, ResizableHandle }

================
File: components/ui/scroll-area.tsx
================
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

const ScrollArea = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.Root>
>(({ className, children, ...props }, ref) => (
  <ScrollAreaPrimitive.Root
    ref={ref}
    className={cn("relative overflow-hidden", className)}
    {...props}
  >
    <ScrollAreaPrimitive.Viewport className="h-full w-full rounded-[inherit]">
      {children}
    </ScrollAreaPrimitive.Viewport>
    <ScrollBar />
    <ScrollAreaPrimitive.Corner />
  </ScrollAreaPrimitive.Root>
))
ScrollArea.displayName = ScrollAreaPrimitive.Root.displayName

const ScrollBar = React.forwardRef<
  React.ElementRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>,
  React.ComponentPropsWithoutRef<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>
>(({ className, orientation = "vertical", ...props }, ref) => (
  <ScrollAreaPrimitive.ScrollAreaScrollbar
    ref={ref}
    orientation={orientation}
    className={cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" &&
        "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" &&
        "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    )}
    {...props}
  >
    <ScrollAreaPrimitive.ScrollAreaThumb className="relative flex-1 rounded-full bg-border" />
  </ScrollAreaPrimitive.ScrollAreaScrollbar>
))
ScrollBar.displayName = ScrollAreaPrimitive.ScrollAreaScrollbar.displayName

export { ScrollArea, ScrollBar }

================
File: components/ui/select.tsx
================
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { Check, ChevronDown, ChevronUp } from "lucide-react"

import { cn } from "@/lib/utils"

const Select = SelectPrimitive.Root

const SelectGroup = SelectPrimitive.Group

const SelectValue = SelectPrimitive.Value

const SelectTrigger = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Trigger>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Trigger
    ref={ref}
    className={cn(
      "flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    )}
    {...props}
  >
    {children}
    <SelectPrimitive.Icon asChild>
      <ChevronDown className="h-4 w-4 opacity-50" />
    </SelectPrimitive.Icon>
  </SelectPrimitive.Trigger>
))
SelectTrigger.displayName = SelectPrimitive.Trigger.displayName

const SelectScrollUpButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollUpButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollUpButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollUpButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronUp className="h-4 w-4" />
  </SelectPrimitive.ScrollUpButton>
))
SelectScrollUpButton.displayName = SelectPrimitive.ScrollUpButton.displayName

const SelectScrollDownButton = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.ScrollDownButton>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.ScrollDownButton>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.ScrollDownButton
    ref={ref}
    className={cn(
      "flex cursor-default items-center justify-center py-1",
      className
    )}
    {...props}
  >
    <ChevronDown className="h-4 w-4" />
  </SelectPrimitive.ScrollDownButton>
))
SelectScrollDownButton.displayName =
  SelectPrimitive.ScrollDownButton.displayName

const SelectContent = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Content>
>(({ className, children, position = "popper", ...props }, ref) => (
  <SelectPrimitive.Portal>
    <SelectPrimitive.Content
      ref={ref}
      className={cn(
        "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
        position === "popper" &&
          "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
        className
      )}
      position={position}
      {...props}
    >
      <SelectScrollUpButton />
      <SelectPrimitive.Viewport
        className={cn(
          "p-1",
          position === "popper" &&
            "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
        )}
      >
        {children}
      </SelectPrimitive.Viewport>
      <SelectScrollDownButton />
    </SelectPrimitive.Content>
  </SelectPrimitive.Portal>
))
SelectContent.displayName = SelectPrimitive.Content.displayName

const SelectLabel = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Label>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Label>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Label
    ref={ref}
    className={cn("py-1.5 pl-8 pr-2 text-sm font-semibold", className)}
    {...props}
  />
))
SelectLabel.displayName = SelectPrimitive.Label.displayName

const SelectItem = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Item>
>(({ className, children, ...props }, ref) => (
  <SelectPrimitive.Item
    ref={ref}
    className={cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    )}
    {...props}
  >
    <span className="absolute left-2 flex h-3.5 w-3.5 items-center justify-center">
      <SelectPrimitive.ItemIndicator>
        <Check className="h-4 w-4" />
      </SelectPrimitive.ItemIndicator>
    </span>

    <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
  </SelectPrimitive.Item>
))
SelectItem.displayName = SelectPrimitive.Item.displayName

const SelectSeparator = React.forwardRef<
  React.ElementRef<typeof SelectPrimitive.Separator>,
  React.ComponentPropsWithoutRef<typeof SelectPrimitive.Separator>
>(({ className, ...props }, ref) => (
  <SelectPrimitive.Separator
    ref={ref}
    className={cn("-mx-1 my-1 h-px bg-muted", className)}
    {...props}
  />
))
SelectSeparator.displayName = SelectPrimitive.Separator.displayName

export {
  Select,
  SelectGroup,
  SelectValue,
  SelectTrigger,
  SelectContent,
  SelectLabel,
  SelectItem,
  SelectSeparator,
  SelectScrollUpButton,
  SelectScrollDownButton,
}

================
File: components/ui/separator.tsx
================
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

const Separator = React.forwardRef<
  React.ElementRef<typeof SeparatorPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SeparatorPrimitive.Root>
>(
  (
    { className, orientation = "horizontal", decorative = true, ...props },
    ref
  ) => (
    <SeparatorPrimitive.Root
      ref={ref}
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "shrink-0 bg-border",
        orientation === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        className
      )}
      {...props}
    />
  )
)
Separator.displayName = SeparatorPrimitive.Root.displayName

export { Separator }

================
File: components/ui/sheet.tsx
================
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const Sheet = SheetPrimitive.Root

const SheetTrigger = SheetPrimitive.Trigger

const SheetClose = SheetPrimitive.Close

const SheetPortal = SheetPrimitive.Portal

const SheetOverlay = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Overlay
    className={cn(
      "fixed inset-0 z-50 bg-black/80  data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
    ref={ref}
  />
))
SheetOverlay.displayName = SheetPrimitive.Overlay.displayName

const sheetVariants = cva(
  "fixed z-50 gap-4 bg-background p-6 shadow-lg transition ease-in-out data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
  {
    variants: {
      side: {
        top: "inset-x-0 top-0 border-b data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top",
        bottom:
          "inset-x-0 bottom-0 border-t data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom",
        left: "inset-y-0 left-0 h-full w-3/4 border-r data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left sm:max-w-sm",
        right:
          "inset-y-0 right-0 h-full w-3/4  border-l data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right sm:max-w-sm",
      },
    },
    defaultVariants: {
      side: "right",
    },
  }
)

interface SheetContentProps
  extends React.ComponentPropsWithoutRef<typeof SheetPrimitive.Content>,
    VariantProps<typeof sheetVariants> {}

const SheetContent = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Content>,
  SheetContentProps
>(({ side = "right", className, children, ...props }, ref) => (
  <SheetPortal>
    <SheetOverlay />
    <SheetPrimitive.Content
      ref={ref}
      className={cn(sheetVariants({ side }), className)}
      {...props}
    >
      {children}
      <SheetPrimitive.Close className="absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-secondary">
        <X className="h-4 w-4" />
        <span className="sr-only">Close</span>
      </SheetPrimitive.Close>
    </SheetPrimitive.Content>
  </SheetPortal>
))
SheetContent.displayName = SheetPrimitive.Content.displayName

const SheetHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-2 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
SheetHeader.displayName = "SheetHeader"

const SheetFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
SheetFooter.displayName = "SheetFooter"

const SheetTitle = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Title>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Title
    ref={ref}
    className={cn("text-lg font-semibold text-foreground", className)}
    {...props}
  />
))
SheetTitle.displayName = SheetPrimitive.Title.displayName

const SheetDescription = React.forwardRef<
  React.ElementRef<typeof SheetPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof SheetPrimitive.Description>
>(({ className, ...props }, ref) => (
  <SheetPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
SheetDescription.displayName = SheetPrimitive.Description.displayName

export {
  Sheet,
  SheetPortal,
  SheetOverlay,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}

================
File: components/ui/sidebar.tsx
================
"use client"

import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { VariantProps, cva } from "class-variance-authority"
import { PanelLeft } from "lucide-react"

import { useIsMobile } from "@/hooks/use-mobile"
import { cn } from "@/lib/utils"
import { Button } from "@/components/ui/button"
import { Input } from "@/components/ui/input"
import { Separator } from "@/components/ui/separator"
import { Sheet, SheetContent } from "@/components/ui/sheet"
import { Skeleton } from "@/components/ui/skeleton"
import {
  Tooltip,
  TooltipContent,
  TooltipProvider,
  TooltipTrigger,
} from "@/components/ui/tooltip"

const SIDEBAR_COOKIE_NAME = "sidebar:state"
const SIDEBAR_COOKIE_MAX_AGE = 60 * 60 * 24 * 7
const SIDEBAR_WIDTH = "16rem"
const SIDEBAR_WIDTH_MOBILE = "18rem"
const SIDEBAR_WIDTH_ICON = "3rem"
const SIDEBAR_KEYBOARD_SHORTCUT = "b"

type SidebarContext = {
  state: "expanded" | "collapsed"
  open: boolean
  setOpen: (open: boolean) => void
  openMobile: boolean
  setOpenMobile: (open: boolean) => void
  isMobile: boolean
  toggleSidebar: () => void
}

const SidebarContext = React.createContext<SidebarContext | null>(null)

function useSidebar() {
  const context = React.useContext(SidebarContext)
  if (!context) {
    throw new Error("useSidebar must be used within a SidebarProvider.")
  }

  return context
}

const SidebarProvider = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    defaultOpen?: boolean
    open?: boolean
    onOpenChange?: (open: boolean) => void
  }
>(
  (
    {
      defaultOpen = true,
      open: openProp,
      onOpenChange: setOpenProp,
      className,
      style,
      children,
      ...props
    },
    ref
  ) => {
    const isMobile = useIsMobile()
    const [openMobile, setOpenMobile] = React.useState(false)

    // This is the internal state of the sidebar.
    // We use openProp and setOpenProp for control from outside the component.
    const [_open, _setOpen] = React.useState(defaultOpen)
    const open = openProp ?? _open
    const setOpen = React.useCallback(
      (value: boolean | ((value: boolean) => boolean)) => {
        const openState = typeof value === "function" ? value(open) : value
        if (setOpenProp) {
          setOpenProp(openState)
        } else {
          _setOpen(openState)
        }

        // This sets the cookie to keep the sidebar state.
        document.cookie = `${SIDEBAR_COOKIE_NAME}=${openState}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}`
      },
      [setOpenProp, open]
    )

    // Helper to toggle the sidebar.
    const toggleSidebar = React.useCallback(() => {
      return isMobile
        ? setOpenMobile((open) => !open)
        : setOpen((open) => !open)
    }, [isMobile, setOpen, setOpenMobile])

    // Adds a keyboard shortcut to toggle the sidebar.
    React.useEffect(() => {
      const handleKeyDown = (event: KeyboardEvent) => {
        if (
          event.key === SIDEBAR_KEYBOARD_SHORTCUT &&
          (event.metaKey || event.ctrlKey)
        ) {
          event.preventDefault()
          toggleSidebar()
        }
      }

      window.addEventListener("keydown", handleKeyDown)
      return () => window.removeEventListener("keydown", handleKeyDown)
    }, [toggleSidebar])

    // We add a state so that we can do data-state="expanded" or "collapsed".
    // This makes it easier to style the sidebar with Tailwind classes.
    const state = open ? "expanded" : "collapsed"

    const contextValue = React.useMemo<SidebarContext>(
      () => ({
        state,
        open,
        setOpen,
        isMobile,
        openMobile,
        setOpenMobile,
        toggleSidebar,
      }),
      [state, open, setOpen, isMobile, openMobile, setOpenMobile, toggleSidebar]
    )

    return (
      <SidebarContext.Provider value={contextValue}>
        <TooltipProvider delayDuration={0}>
          <div
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH,
                "--sidebar-width-icon": SIDEBAR_WIDTH_ICON,
                ...style,
              } as React.CSSProperties
            }
            className={cn(
              "group/sidebar-wrapper flex min-h-svh w-full has-[[data-variant=inset]]:bg-sidebar",
              className
            )}
            ref={ref}
            {...props}
          >
            {children}
          </div>
        </TooltipProvider>
      </SidebarContext.Provider>
    )
  }
)
SidebarProvider.displayName = "SidebarProvider"

const Sidebar = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    side?: "left" | "right"
    variant?: "sidebar" | "floating" | "inset"
    collapsible?: "offcanvas" | "icon" | "none"
  }
>(
  (
    {
      side = "left",
      variant = "sidebar",
      collapsible = "offcanvas",
      className,
      children,
      ...props
    },
    ref
  ) => {
    const { isMobile, state, openMobile, setOpenMobile } = useSidebar()

    if (collapsible === "none") {
      return (
        <div
          className={cn(
            "flex h-full w-[--sidebar-width] flex-col bg-sidebar text-sidebar-foreground",
            className
          )}
          ref={ref}
          {...props}
        >
          {children}
        </div>
      )
    }

    if (isMobile) {
      return (
        <Sheet open={openMobile} onOpenChange={setOpenMobile} {...props}>
          <SheetContent
            data-sidebar="sidebar"
            data-mobile="true"
            className="w-[--sidebar-width] bg-sidebar p-0 text-sidebar-foreground [&>button]:hidden"
            style={
              {
                "--sidebar-width": SIDEBAR_WIDTH_MOBILE,
              } as React.CSSProperties
            }
            side={side}
          >
            <div className="flex h-full w-full flex-col">{children}</div>
          </SheetContent>
        </Sheet>
      )
    }

    return (
      <div
        ref={ref}
        className="group peer hidden md:block text-sidebar-foreground"
        data-state={state}
        data-collapsible={state === "collapsed" ? collapsible : ""}
        data-variant={variant}
        data-side={side}
      >
        {/* This is what handles the sidebar gap on desktop */}
        <div
          className={cn(
            "duration-200 relative h-svh w-[--sidebar-width] bg-transparent transition-[width] ease-linear",
            "group-data-[collapsible=offcanvas]:w-0",
            "group-data-[side=right]:rotate-180",
            variant === "floating" || variant === "inset"
              ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4))]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon]"
          )}
        />
        <div
          className={cn(
            "duration-200 fixed inset-y-0 z-10 hidden h-svh w-[--sidebar-width] transition-[left,right,width] ease-linear md:flex",
            side === "left"
              ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]"
              : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]",
            // Adjust the padding for floating and inset variants.
            variant === "floating" || variant === "inset"
              ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)_+_theme(spacing.4)_+2px)]"
              : "group-data-[collapsible=icon]:w-[--sidebar-width-icon] group-data-[side=left]:border-r group-data-[side=right]:border-l",
            className
          )}
          {...props}
        >
          <div
            data-sidebar="sidebar"
            className="flex h-full w-full flex-col bg-sidebar group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:border-sidebar-border group-data-[variant=floating]:shadow"
          >
            {children}
          </div>
        </div>
      </div>
    )
  }
)
Sidebar.displayName = "Sidebar"

const SidebarTrigger = React.forwardRef<
  React.ElementRef<typeof Button>,
  React.ComponentProps<typeof Button>
>(({ className, onClick, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <Button
      ref={ref}
      data-sidebar="trigger"
      variant="ghost"
      size="icon"
      className={cn("h-7 w-7", className)}
      onClick={(event) => {
        onClick?.(event)
        toggleSidebar()
      }}
      {...props}
    >
      <PanelLeft />
      <span className="sr-only">Toggle Sidebar</span>
    </Button>
  )
})
SidebarTrigger.displayName = "SidebarTrigger"

const SidebarRail = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button">
>(({ className, ...props }, ref) => {
  const { toggleSidebar } = useSidebar()

  return (
    <button
      ref={ref}
      data-sidebar="rail"
      aria-label="Toggle Sidebar"
      tabIndex={-1}
      onClick={toggleSidebar}
      title="Toggle Sidebar"
      className={cn(
        "absolute inset-y-0 z-20 hidden w-4 -translate-x-1/2 transition-all ease-linear after:absolute after:inset-y-0 after:left-1/2 after:w-[2px] hover:after:bg-sidebar-border group-data-[side=left]:-right-4 group-data-[side=right]:left-0 sm:flex",
        "[[data-side=left]_&]:cursor-w-resize [[data-side=right]_&]:cursor-e-resize",
        "[[data-side=left][data-state=collapsed]_&]:cursor-e-resize [[data-side=right][data-state=collapsed]_&]:cursor-w-resize",
        "group-data-[collapsible=offcanvas]:translate-x-0 group-data-[collapsible=offcanvas]:after:left-full group-data-[collapsible=offcanvas]:hover:bg-sidebar",
        "[[data-side=left][data-collapsible=offcanvas]_&]:-right-2",
        "[[data-side=right][data-collapsible=offcanvas]_&]:-left-2",
        className
      )}
      {...props}
    />
  )
})
SidebarRail.displayName = "SidebarRail"

const SidebarInset = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"main">
>(({ className, ...props }, ref) => {
  return (
    <main
      ref={ref}
      className={cn(
        "relative flex min-h-svh flex-1 flex-col bg-background",
        "peer-data-[variant=inset]:min-h-[calc(100svh-theme(spacing.4))] md:peer-data-[variant=inset]:m-2 md:peer-data-[state=collapsed]:peer-data-[variant=inset]:ml-2 md:peer-data-[variant=inset]:ml-0 md:peer-data-[variant=inset]:rounded-xl md:peer-data-[variant=inset]:shadow",
        className
      )}
      {...props}
    />
  )
})
SidebarInset.displayName = "SidebarInset"

const SidebarInput = React.forwardRef<
  React.ElementRef<typeof Input>,
  React.ComponentProps<typeof Input>
>(({ className, ...props }, ref) => {
  return (
    <Input
      ref={ref}
      data-sidebar="input"
      className={cn(
        "h-8 w-full bg-background shadow-none focus-visible:ring-2 focus-visible:ring-sidebar-ring",
        className
      )}
      {...props}
    />
  )
})
SidebarInput.displayName = "SidebarInput"

const SidebarHeader = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="header"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarHeader.displayName = "SidebarHeader"

const SidebarFooter = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="footer"
      className={cn("flex flex-col gap-2 p-2", className)}
      {...props}
    />
  )
})
SidebarFooter.displayName = "SidebarFooter"

const SidebarSeparator = React.forwardRef<
  React.ElementRef<typeof Separator>,
  React.ComponentProps<typeof Separator>
>(({ className, ...props }, ref) => {
  return (
    <Separator
      ref={ref}
      data-sidebar="separator"
      className={cn("mx-2 w-auto bg-sidebar-border", className)}
      {...props}
    />
  )
})
SidebarSeparator.displayName = "SidebarSeparator"

const SidebarContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="content"
      className={cn(
        "flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarContent.displayName = "SidebarContent"

const SidebarGroup = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => {
  return (
    <div
      ref={ref}
      data-sidebar="group"
      className={cn("relative flex w-full min-w-0 flex-col p-2", className)}
      {...props}
    />
  )
})
SidebarGroup.displayName = "SidebarGroup"

const SidebarGroupLabel = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "div"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-label"
      className={cn(
        "duration-200 flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium text-sidebar-foreground/70 outline-none ring-sidebar-ring transition-[margin,opa] ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupLabel.displayName = "SidebarGroupLabel"

const SidebarGroupAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & { asChild?: boolean }
>(({ className, asChild = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="group-action"
      className={cn(
        "absolute right-3 top-3.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarGroupAction.displayName = "SidebarGroupAction"

const SidebarGroupContent = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="group-content"
    className={cn("w-full text-sm", className)}
    {...props}
  />
))
SidebarGroupContent.displayName = "SidebarGroupContent"

const SidebarMenu = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu"
    className={cn("flex w-full min-w-0 flex-col gap-1", className)}
    {...props}
  />
))
SidebarMenu.displayName = "SidebarMenu"

const SidebarMenuItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li
    ref={ref}
    data-sidebar="menu-item"
    className={cn("group/menu-item relative", className)}
    {...props}
  />
))
SidebarMenuItem.displayName = "SidebarMenuItem"

const sidebarMenuButtonVariants = cva(
  "peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-none ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-[[data-sidebar=menu-action]]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:!size-8 group-data-[collapsible=icon]:!p-2 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground",
        outline:
          "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]",
      },
      size: {
        default: "h-8 text-sm",
        sm: "h-7 text-xs",
        lg: "h-12 text-sm group-data-[collapsible=icon]:!p-0",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const SidebarMenuButton = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    isActive?: boolean
    tooltip?: string | React.ComponentProps<typeof TooltipContent>
  } & VariantProps<typeof sidebarMenuButtonVariants>
>(
  (
    {
      asChild = false,
      isActive = false,
      variant = "default",
      size = "default",
      tooltip,
      className,
      ...props
    },
    ref
  ) => {
    const Comp = asChild ? Slot : "button"
    const { isMobile, state } = useSidebar()

    const button = (
      <Comp
        ref={ref}
        data-sidebar="menu-button"
        data-size={size}
        data-active={isActive}
        className={cn(sidebarMenuButtonVariants({ variant, size }), className)}
        {...props}
      />
    )

    if (!tooltip) {
      return button
    }

    if (typeof tooltip === "string") {
      tooltip = {
        children: tooltip,
      }
    }

    return (
      <Tooltip>
        <TooltipTrigger asChild>{button}</TooltipTrigger>
        <TooltipContent
          side="right"
          align="center"
          hidden={state !== "collapsed" || isMobile}
          {...tooltip}
        />
      </Tooltip>
    )
  }
)
SidebarMenuButton.displayName = "SidebarMenuButton"

const SidebarMenuAction = React.forwardRef<
  HTMLButtonElement,
  React.ComponentProps<"button"> & {
    asChild?: boolean
    showOnHover?: boolean
  }
>(({ className, asChild = false, showOnHover = false, ...props }, ref) => {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-action"
      className={cn(
        "absolute right-1 top-1.5 flex aspect-square w-5 items-center justify-center rounded-md p-0 text-sidebar-foreground outline-none ring-sidebar-ring transition-transform hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 peer-hover/menu-button:text-sidebar-accent-foreground [&>svg]:size-4 [&>svg]:shrink-0",
        // Increases the hit area of the button on mobile.
        "after:absolute after:-inset-2 after:md:hidden",
        "peer-data-[size=sm]/menu-button:top-1",
        "peer-data-[size=default]/menu-button:top-1.5",
        "peer-data-[size=lg]/menu-button:top-2.5",
        "group-data-[collapsible=icon]:hidden",
        showOnHover &&
          "group-focus-within/menu-item:opacity-100 group-hover/menu-item:opacity-100 data-[state=open]:opacity-100 peer-data-[active=true]/menu-button:text-sidebar-accent-foreground md:opacity-0",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuAction.displayName = "SidebarMenuAction"

const SidebarMenuBadge = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div">
>(({ className, ...props }, ref) => (
  <div
    ref={ref}
    data-sidebar="menu-badge"
    className={cn(
      "absolute right-1 flex h-5 min-w-5 items-center justify-center rounded-md px-1 text-xs font-medium tabular-nums text-sidebar-foreground select-none pointer-events-none",
      "peer-hover/menu-button:text-sidebar-accent-foreground peer-data-[active=true]/menu-button:text-sidebar-accent-foreground",
      "peer-data-[size=sm]/menu-button:top-1",
      "peer-data-[size=default]/menu-button:top-1.5",
      "peer-data-[size=lg]/menu-button:top-2.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuBadge.displayName = "SidebarMenuBadge"

const SidebarMenuSkeleton = React.forwardRef<
  HTMLDivElement,
  React.ComponentProps<"div"> & {
    showIcon?: boolean
  }
>(({ className, showIcon = false, ...props }, ref) => {
  // Random width between 50 to 90%.
  const width = React.useMemo(() => {
    return `${Math.floor(Math.random() * 40) + 50}%`
  }, [])

  return (
    <div
      ref={ref}
      data-sidebar="menu-skeleton"
      className={cn("rounded-md h-8 flex gap-2 px-2 items-center", className)}
      {...props}
    >
      {showIcon && (
        <Skeleton
          className="size-4 rounded-md"
          data-sidebar="menu-skeleton-icon"
        />
      )}
      <Skeleton
        className="h-4 flex-1 max-w-[--skeleton-width]"
        data-sidebar="menu-skeleton-text"
        style={
          {
            "--skeleton-width": width,
          } as React.CSSProperties
        }
      />
    </div>
  )
})
SidebarMenuSkeleton.displayName = "SidebarMenuSkeleton"

const SidebarMenuSub = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    data-sidebar="menu-sub"
    className={cn(
      "mx-3.5 flex min-w-0 translate-x-px flex-col gap-1 border-l border-sidebar-border px-2.5 py-0.5",
      "group-data-[collapsible=icon]:hidden",
      className
    )}
    {...props}
  />
))
SidebarMenuSub.displayName = "SidebarMenuSub"

const SidebarMenuSubItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ ...props }, ref) => <li ref={ref} {...props} />)
SidebarMenuSubItem.displayName = "SidebarMenuSubItem"

const SidebarMenuSubButton = React.forwardRef<
  HTMLAnchorElement,
  React.ComponentProps<"a"> & {
    asChild?: boolean
    size?: "sm" | "md"
    isActive?: boolean
  }
>(({ asChild = false, size = "md", isActive, className, ...props }, ref) => {
  const Comp = asChild ? Slot : "a"

  return (
    <Comp
      ref={ref}
      data-sidebar="menu-sub-button"
      data-size={size}
      data-active={isActive}
      className={cn(
        "flex h-7 min-w-0 -translate-x-px items-center gap-2 overflow-hidden rounded-md px-2 text-sidebar-foreground outline-none ring-sidebar-ring hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 aria-disabled:pointer-events-none aria-disabled:opacity-50 [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0 [&>svg]:text-sidebar-accent-foreground",
        "data-[active=true]:bg-sidebar-accent data-[active=true]:text-sidebar-accent-foreground",
        size === "sm" && "text-xs",
        size === "md" && "text-sm",
        "group-data-[collapsible=icon]:hidden",
        className
      )}
      {...props}
    />
  )
})
SidebarMenuSubButton.displayName = "SidebarMenuSubButton"

export {
  Sidebar,
  SidebarContent,
  SidebarFooter,
  SidebarGroup,
  SidebarGroupAction,
  SidebarGroupContent,
  SidebarGroupLabel,
  SidebarHeader,
  SidebarInput,
  SidebarInset,
  SidebarMenu,
  SidebarMenuAction,
  SidebarMenuBadge,
  SidebarMenuButton,
  SidebarMenuItem,
  SidebarMenuSkeleton,
  SidebarMenuSub,
  SidebarMenuSubButton,
  SidebarMenuSubItem,
  SidebarProvider,
  SidebarRail,
  SidebarSeparator,
  SidebarTrigger,
  useSidebar,
}

================
File: components/ui/skeleton.tsx
================
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-muted", className)}
      {...props}
    />
  )
}

export { Skeleton }

================
File: components/ui/slider.tsx
================
"use client"

import * as React from "react"
import * as SliderPrimitive from "@radix-ui/react-slider"

import { cn } from "@/lib/utils"

const Slider = React.forwardRef<
  React.ElementRef<typeof SliderPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof SliderPrimitive.Root>
>(({ className, ...props }, ref) => (
  <SliderPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex w-full touch-none select-none items-center",
      className
    )}
    {...props}
  >
    <SliderPrimitive.Track className="relative h-2 w-full grow overflow-hidden rounded-full bg-secondary">
      <SliderPrimitive.Range className="absolute h-full bg-primary" />
    </SliderPrimitive.Track>
    <SliderPrimitive.Thumb className="block h-5 w-5 rounded-full border-2 border-primary bg-background ring-offset-background transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50" />
  </SliderPrimitive.Root>
))
Slider.displayName = SliderPrimitive.Root.displayName

export { Slider }

================
File: components/ui/sonner.tsx
================
"use client"

import { useTheme } from "next-themes"
import { Toaster as Sonner } from "sonner"

type ToasterProps = React.ComponentProps<typeof Sonner>

const Toaster = ({ ...props }: ToasterProps) => {
  const { theme = "system" } = useTheme()

  return (
    <Sonner
      theme={theme as ToasterProps["theme"]}
      className="toaster group"
      toastOptions={{
        classNames: {
          toast:
            "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
          description: "group-[.toast]:text-muted-foreground",
          actionButton:
            "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
          cancelButton:
            "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground",
        },
      }}
      {...props}
    />
  )
}

export { Toaster }

================
File: components/ui/switch.tsx
================
"use client"

import * as React from "react"
import * as SwitchPrimitives from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

const Switch = React.forwardRef<
  React.ElementRef<typeof SwitchPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof SwitchPrimitives.Root>
>(({ className, ...props }, ref) => (
  <SwitchPrimitives.Root
    className={cn(
      "peer inline-flex h-6 w-11 shrink-0 cursor-pointer items-center rounded-full border-2 border-transparent transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=unchecked]:bg-input",
      className
    )}
    {...props}
    ref={ref}
  >
    <SwitchPrimitives.Thumb
      className={cn(
        "pointer-events-none block h-5 w-5 rounded-full bg-background shadow-lg ring-0 transition-transform data-[state=checked]:translate-x-5 data-[state=unchecked]:translate-x-0"
      )}
    />
  </SwitchPrimitives.Root>
))
Switch.displayName = SwitchPrimitives.Root.displayName

export { Switch }

================
File: components/ui/table.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}

================
File: components/ui/tabs.tsx
================
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

const Tabs = TabsPrimitive.Root

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
))
TabsList.displayName = TabsPrimitive.List.displayName

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm",
      className
    )}
    {...props}
  />
))
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
))
TabsContent.displayName = TabsPrimitive.Content.displayName

export { Tabs, TabsList, TabsTrigger, TabsContent }

================
File: components/ui/textarea.tsx
================
import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef<
  HTMLTextAreaElement,
  React.ComponentProps<"textarea">
>(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props}
    />
  )
})
Textarea.displayName = "Textarea"

export { Textarea }

================
File: components/ui/toast.tsx
================
"use client"

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva, type VariantProps } from "class-variance-authority"
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Viewport>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Viewport>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props}
  />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Root>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Root> &
    VariantProps<typeof toastVariants>
>(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props}
    />
  )
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Action>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Action>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props}
  />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Close>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Close>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}
  >
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Title>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Title>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Title
    ref={ref}
    className={cn("text-sm font-semibold", className)}
    {...props}
  />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef<
  React.ElementRef<typeof ToastPrimitives.Description>,
  React.ComponentPropsWithoutRef<typeof ToastPrimitives.Description>
>(({ className, ...props }, ref) => (
  <ToastPrimitives.Description
    ref={ref}
    className={cn("text-sm opacity-90", className)}
    {...props}
  />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

type ToastProps = React.ComponentPropsWithoutRef<typeof Toast>

type ToastActionElement = React.ReactElement<typeof ToastAction>

export {
  type ToastProps,
  type ToastActionElement,
  ToastProvider,
  ToastViewport,
  Toast,
  ToastTitle,
  ToastDescription,
  ToastClose,
  ToastAction,
}

================
File: components/ui/toaster.tsx
================
"use client"

import { useToast } from "@/hooks/use-toast"
import {
  Toast,
  ToastClose,
  ToastDescription,
  ToastProvider,
  ToastTitle,
  ToastViewport,
} from "@/components/ui/toast"

export function Toaster() {
  const { toasts } = useToast()

  return (
    <ToastProvider>
      {toasts.map(function ({ id, title, description, action, ...props }) {
        return (
          <Toast key={id} {...props}>
            <div className="grid gap-1">
              {title && <ToastTitle>{title}</ToastTitle>}
              {description && (
                <ToastDescription>{description}</ToastDescription>
              )}
            </div>
            {action}
            <ToastClose />
          </Toast>
        )
      })}
      <ToastViewport />
    </ToastProvider>
  )
}

================
File: components/ui/toggle-group.tsx
================
"use client"

import * as React from "react"
import * as ToggleGroupPrimitive from "@radix-ui/react-toggle-group"
import { type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"
import { toggleVariants } from "@/components/ui/toggle"

const ToggleGroupContext = React.createContext<
  VariantProps<typeof toggleVariants>
>({
  size: "default",
  variant: "default",
})

const ToggleGroup = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, children, ...props }, ref) => (
  <ToggleGroupPrimitive.Root
    ref={ref}
    className={cn("flex items-center justify-center gap-1", className)}
    {...props}
  >
    <ToggleGroupContext.Provider value={{ variant, size }}>
      {children}
    </ToggleGroupContext.Provider>
  </ToggleGroupPrimitive.Root>
))

ToggleGroup.displayName = ToggleGroupPrimitive.Root.displayName

const ToggleGroupItem = React.forwardRef<
  React.ElementRef<typeof ToggleGroupPrimitive.Item>,
  React.ComponentPropsWithoutRef<typeof ToggleGroupPrimitive.Item> &
    VariantProps<typeof toggleVariants>
>(({ className, children, variant, size, ...props }, ref) => {
  const context = React.useContext(ToggleGroupContext)

  return (
    <ToggleGroupPrimitive.Item
      ref={ref}
      className={cn(
        toggleVariants({
          variant: context.variant || variant,
          size: context.size || size,
        }),
        className
      )}
      {...props}
    >
      {children}
    </ToggleGroupPrimitive.Item>
  )
})

ToggleGroupItem.displayName = ToggleGroupPrimitive.Item.displayName

export { ToggleGroup, ToggleGroupItem }

================
File: components/ui/toggle.tsx
================
"use client"

import * as React from "react"
import * as TogglePrimitive from "@radix-ui/react-toggle"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const toggleVariants = cva(
  "inline-flex items-center justify-center rounded-md text-sm font-medium ring-offset-background transition-colors hover:bg-muted hover:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=on]:bg-accent data-[state=on]:text-accent-foreground [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0 gap-2",
  {
    variants: {
      variant: {
        default: "bg-transparent",
        outline:
          "border border-input bg-transparent hover:bg-accent hover:text-accent-foreground",
      },
      size: {
        default: "h-10 px-3 min-w-10",
        sm: "h-9 px-2.5 min-w-9",
        lg: "h-11 px-5 min-w-11",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

const Toggle = React.forwardRef<
  React.ElementRef<typeof TogglePrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof TogglePrimitive.Root> &
    VariantProps<typeof toggleVariants>
>(({ className, variant, size, ...props }, ref) => (
  <TogglePrimitive.Root
    ref={ref}
    className={cn(toggleVariants({ variant, size, className }))}
    {...props}
  />
))

Toggle.displayName = TogglePrimitive.Root.displayName

export { Toggle, toggleVariants }

================
File: components/ui/tooltip.tsx
================
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

const TooltipProvider = TooltipPrimitive.Provider

const Tooltip = TooltipPrimitive.Root

const TooltipTrigger = TooltipPrimitive.Trigger

const TooltipContent = React.forwardRef<
  React.ElementRef<typeof TooltipPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TooltipPrimitive.Content>
>(({ className, sideOffset = 4, ...props }, ref) => (
  <TooltipPrimitive.Content
    ref={ref}
    sideOffset={sideOffset}
    className={cn(
      "z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      className
    )}
    {...props}
  />
))
TooltipContent.displayName = TooltipPrimitive.Content.displayName

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }

================
File: components/ui/use-mobile.tsx
================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}

================
File: components/ui/use-toast.ts
================
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

================
File: hooks/use-mobile.tsx
================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}

================
File: hooks/use-toast.ts
================
"use client"

// Inspired by react-hot-toast library
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }

================
File: lib/auth.ts
================
"use server"

import { cookies } from "next/headers"
import bcrypt from "bcryptjs"
import { createClient } from "@libsql/client"

const client = createClient({
  url: process.env.TURSO_DATABASE_URL || "",
  authToken: process.env.TURSO_AUTH_TOKEN || "",
})

export async function setUserCookie(user: { id: number; username: string; role: string }) {
  console.log("Setting user cookie:", user)
  try {
    const cookieStore = cookies()
    const userString = JSON.stringify(user)
    cookieStore.set("user", userString)
    console.log("User cookie set successfully")
  } catch (error) {
    console.error("Error in setUserCookie:", error)
    console.error("Error details:", JSON.stringify(error, Object.getOwnPropertyNames(error)))
    throw new Error("Failed to set user cookie: " + (error instanceof Error ? error.message : String(error)))
  }
}

export async function getUserFromCookie() {
  console.log("Getting user from cookie")
  try {
    const cookieStore = cookies()
    const userCookie = cookieStore.get("user")
    if (userCookie && userCookie.value) {
      const user = JSON.parse(userCookie.value)
      console.log("User found in cookie:", user)
      if (user && user.id !== undefined && user.username && user.role) {
        return user
      }
    }
    console.log("No valid user found in cookie")
    return null
  } catch (error) {
    console.error("Error in getUserFromCookie:", error)
    console.error("Error details:", JSON.stringify(error, Object.getOwnPropertyNames(error)))
    return null
  }
}

export async function clearUserCookie() {
  try {
    const cookieStore = cookies()
    cookieStore.delete("user")
    console.log("User cookie cleared")
  } catch (error) {
    console.error("Error in clearUserCookie:", error)
    console.error("Error details:", JSON.stringify(error, Object.getOwnPropertyNames(error)))
    throw new Error("Failed to clear user cookie: " + (error instanceof Error ? error.message : String(error)))
  }
}

export async function loginUser(username: string, password: string) {
  try {
    const result = await client.execute({
      sql: "SELECT * FROM User WHERE Username = ?",
      args: [username],
    })

    if (result.rows.length === 0) {
      return { success: false, error: "Invalid credentials" }
    }

    const user = result.rows[0]
    const isMatch = await bcrypt.compare(password, user.Password)

    if (!isMatch) {
      return { success: false, error: "Invalid credentials" }
    }

    const userForCookie = {
      id: user.UserId,
      username: user.Username,
      role: user.Role || "player",
    }

    await setUserCookie(userForCookie)

    return { success: true, role: userForCookie.role }
  } catch (error) {
    console.error("Login error:", error)
    return { success: false, error: "An unexpected error occurred during login" }
  }
}

export async function loginDM() {
  try {
    const userForCookie = {
      id: 0,
      username: "DM_User",
      role: "DM" as const,
    }
    await setUserCookie(userForCookie)
    return { success: true, role: "DM" }
  } catch (error) {
    console.error("DM Login error:", error)
    return { success: false, error: "An error occurred during DM login" }
  }
}

================
File: lib/session.ts
================
import type { IronSessionOptions } from "iron-session"

export const sessionOptions: IronSessionOptions = {
  password: process.env.SECRET_COOKIE_PASSWORD as string,
  cookieName: "virtual-tabletop-session",
  cookieOptions: {
    secure: process.env.NODE_ENV === "production",
  },
}

================
File: lib/utils.ts
================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

================
File: next.config.mjs
================
let userConfig = undefined
try {
  userConfig = await import('./v0-user-next.config')
} catch (e) {
  // ignore error
}

/** @type {import('next').NextConfig} */
const nextConfig = {
  eslint: {
    ignoreDuringBuilds: true,
  },
  typescript: {
    ignoreBuildErrors: true,
  },
  images: {
    unoptimized: true,
  },
  experimental: {
    webpackBuildWorker: true,
    parallelServerBuildTraces: true,
    parallelServerCompiles: true,
  },
}

mergeConfig(nextConfig, userConfig)

function mergeConfig(nextConfig, userConfig) {
  if (!userConfig) {
    return
  }

  for (const key in userConfig) {
    if (
      typeof nextConfig[key] === 'object' &&
      !Array.isArray(nextConfig[key])
    ) {
      nextConfig[key] = {
        ...nextConfig[key],
        ...userConfig[key],
      }
    } else {
      nextConfig[key] = userConfig[key]
    }
  }
}

export default nextConfig

================
File: package.json
================
{
  "name": "my-v0-project",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.9.1",
    "@libsql/client": "latest",
    "@prisma/client": "^6.4.1",
    "@radix-ui/react-accordion": "^1.2.2",
    "@radix-ui/react-alert-dialog": "^1.1.4",
    "@radix-ui/react-aspect-ratio": "^1.1.1",
    "@radix-ui/react-avatar": "^1.1.2",
    "@radix-ui/react-checkbox": "^1.1.3",
    "@radix-ui/react-collapsible": "^1.1.2",
    "@radix-ui/react-context-menu": "^2.2.4",
    "@radix-ui/react-dialog": "^1.1.4",
    "@radix-ui/react-dropdown-menu": "^2.1.4",
    "@radix-ui/react-hover-card": "^1.1.4",
    "@radix-ui/react-label": "^2.1.1",
    "@radix-ui/react-menubar": "^1.1.4",
    "@radix-ui/react-navigation-menu": "^1.2.3",
    "@radix-ui/react-popover": "^1.1.6",
    "@radix-ui/react-progress": "^1.1.1",
    "@radix-ui/react-radio-group": "^1.2.2",
    "@radix-ui/react-scroll-area": "^1.2.2",
    "@radix-ui/react-select": "^2.1.4",
    "@radix-ui/react-separator": "^1.1.1",
    "@radix-ui/react-slider": "^1.2.2",
    "@radix-ui/react-slot": "^1.1.1",
    "@radix-ui/react-switch": "^1.1.2",
    "@radix-ui/react-tabs": "^1.1.2",
    "@radix-ui/react-toast": "^1.2.4",
    "@radix-ui/react-toggle": "^1.1.1",
    "@radix-ui/react-toggle-group": "^1.1.1",
    "@radix-ui/react-tooltip": "^1.1.6",
    "@types/better-sqlite3": "^7.6.12",
    "@types/react": "latest",
    "@types/react-dom": "latest",
    "@vercel/blob": "latest",
    "autoprefixer": "^10.4.20",
    "bcryptjs": "latest",
    "better-sqlite3": "^11.8.1",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "1.0.4",
    "date-fns": "4.1.0",
    "embla-carousel-react": "8.5.1",
    "input-otp": "1.4.1",
    "iron-session": "latest",
    "lucide-react": "^0.454.0",
    "next": "14.2.16",
    "next-themes": "^0.4.4",
    "react": "^18",
    "react-day-picker": "^9.5.1",
    "react-dom": "^18",
    "react-hook-form": "^7.54.1",
    "react-resizable-panels": "^2.1.7",
    "recharts": "2.15.0",
    "sonner": "^1.7.1",
    "tailwind-merge": "^2.5.5",
    "tailwindcss-animate": "^1.0.7",
    "vaul": "^0.9.6",
    "zod": "^3.24.1"
  },
  "devDependencies": {
    "@types/node": "^22",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "postcss": "^8",
    "prisma": "^6.4.1",
    "tailwindcss": "^3.4.17",
    "typescript": "^5"
  }
}

================
File: postcss.config.mjs
================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

================
File: prisma/schema.prisma
================
datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        Int       @id @default(autoincrement())
  username  String    @unique
  password  String
  role      String
  drawings  Drawing[]
}

model Drawing {
  id        String   @id
  path      String
  color     String
  createdBy Int
  createdAt DateTime @default(now())
  user      User     @relation(fields: [createdBy], references: [id])
}

================
File: public/placeholder-logo.svg
================
<svg xmlns="http://www.w3.org/2000/svg" width="215" height="48" fill="none"><path fill="#000" d="M57.588 9.6h6L73.828 38h-5.2l-2.36-6.88h-11.36L52.548 38h-5.2l10.24-28.4Zm7.16 17.16-4.16-12.16-4.16 12.16h8.32Zm23.694-2.24c-.186-1.307-.706-2.32-1.56-3.04-.853-.72-1.866-1.08-3.04-1.08-1.68 0-2.986.613-3.92 1.84-.906 1.227-1.36 2.947-1.36 5.16s.454 3.933 1.36 5.16c.934 1.227 2.24 1.84 3.92 1.84 1.254 0 2.307-.373 3.16-1.12.854-.773 1.387-1.867 1.6-3.28l5.12.24c-.186 1.68-.733 3.147-1.64 4.4-.906 1.227-2.08 2.173-3.52 2.84-1.413.667-2.986 1-4.72 1-2.08 0-3.906-.453-5.48-1.36-1.546-.907-2.76-2.2-3.64-3.88-.853-1.68-1.28-3.627-1.28-5.84 0-2.24.427-4.187 1.28-5.84.88-1.68 2.094-2.973 3.64-3.88 1.574-.907 3.4-1.36 5.48-1.36 1.68 0 3.227.32 4.64.96 1.414.64 2.56 1.56 3.44 2.76.907 1.2 1.454 2.6 1.64 4.2l-5.12.28Zm11.486-7.72.12 3.4c.534-1.227 1.307-2.173 2.32-2.84 1.04-.693 2.267-1.04 3.68-1.04 1.494 0 2.76.387 3.8 1.16 1.067.747 1.827 1.813 2.28 3.2.507-1.44 1.294-2.52 2.36-3.24 1.094-.747 2.414-1.12 3.96-1.12 1.414 0 2.64.307 3.68.92s1.84 1.52 2.4 2.72c.56 1.2.84 2.667.84 4.4V38h-4.96V25.92c0-1.813-.293-3.187-.88-4.12-.56-.96-1.413-1.44-2.56-1.44-.906 0-1.68.213-2.32.64-.64.427-1.133 1.053-1.48 1.88-.32.827-.48 1.84-.48 3.04V38h-4.56V25.92c0-1.2-.133-2.213-.4-3.04-.24-.827-.626-1.453-1.16-1.88-.506-.427-1.133-.64-1.88-.64-.906 0-1.68.227-2.32.68-.64.427-1.133 1.053-1.48 1.88-.32.827-.48 1.827-.48 3V38h-4.96V16.8h4.48Zm26.723 10.6c0-2.24.427-4.187 1.28-5.84.854-1.68 2.067-2.973 3.64-3.88 1.574-.907 3.4-1.36 5.48-1.36 1.84 0 3.494.413 4.96 1.24 1.467.827 2.64 2.08 3.52 3.76.88 1.653 1.347 3.693 1.4 6.12v1.32h-15.08c.107 1.813.614 3.227 1.52 4.24.907.987 2.134 1.48 3.68 1.48.987 0 1.88-.253 2.68-.76a4.803 4.803 0 0 0 1.84-2.2l5.08.36c-.64 2.027-1.84 3.64-3.6 4.84-1.733 1.173-3.733 1.76-6 1.76-2.08 0-3.906-.453-5.48-1.36-1.573-.907-2.786-2.2-3.64-3.88-.853-1.68-1.28-3.627-1.28-5.84Zm15.16-2.04c-.213-1.733-.76-3.013-1.64-3.84-.853-.827-1.893-1.24-3.12-1.24-1.44 0-2.6.453-3.48 1.36-.88.88-1.44 2.12-1.68 3.72h9.92ZM163.139 9.6V38h-5.04V9.6h5.04Zm8.322 7.2.24 5.88-.64-.36c.32-2.053 1.094-3.56 2.32-4.52 1.254-.987 2.787-1.48 4.6-1.48 2.32 0 4.107.733 5.36 2.2 1.254 1.44 1.88 3.387 1.88 5.84V38h-4.96V25.92c0-1.253-.12-2.28-.36-3.08-.24-.8-.64-1.413-1.2-1.84-.533-.427-1.253-.64-2.16-.64-1.44 0-2.573.48-3.4 1.44-.8.933-1.2 2.307-1.2 4.12V38h-4.96V16.8h4.48Zm30.003 7.72c-.186-1.307-.706-2.32-1.56-3.04-.853-.72-1.866-1.08-3.04-1.08-1.68 0-2.986.613-3.92 1.84-.906 1.227-1.36 2.947-1.36 5.16s.454 3.933 1.36 5.16c.934 1.227 2.24 1.84 3.92 1.84 1.254 0 2.307-.373 3.16-1.12.854-.773 1.387-1.867 1.6-3.28l5.12.24c-.186 1.68-.733 3.147-1.64 4.4-.906 1.227-2.08 2.173-3.52 2.84-1.413.667-2.986 1-4.72 1-2.08 0-3.906-.453-5.48-1.36-1.546-.907-2.76-2.2-3.64-3.88-.853-1.68-1.28-3.627-1.28-5.84 0-2.24.427-4.187 1.28-5.84.88-1.68 2.094-2.973 3.64-3.88 1.574-.907 3.4-1.36 5.48-1.36 1.68 0 3.227.32 4.64.96 1.414.64 2.56 1.56 3.44 2.76.907 1.2 1.454 2.6 1.64 4.2l-5.12.28Zm11.443 8.16V38h-5.6v-5.32h5.6Z"/><path fill="#171717" fill-rule="evenodd" d="m7.839 40.783 16.03-28.054L20 6 0 40.783h7.839Zm8.214 0H40L27.99 19.894l-4.02 7.032 3.976 6.914H20.02l-3.967 6.943Z" clip-rule="evenodd"/></svg>

================
File: public/placeholder.svg
================
<svg xmlns="http://www.w3.org/2000/svg" width="1200" height="1200" fill="none"><rect width="1200" height="1200" fill="#EAEAEA" rx="3"/><g opacity=".5"><g opacity=".5"><path fill="#FAFAFA" d="M600.709 736.5c-75.454 0-136.621-61.167-136.621-136.62 0-75.454 61.167-136.621 136.621-136.621 75.453 0 136.62 61.167 136.62 136.621 0 75.453-61.167 136.62-136.62 136.62Z"/><path stroke="#C9C9C9" stroke-width="2.418" d="M600.709 736.5c-75.454 0-136.621-61.167-136.621-136.62 0-75.454 61.167-136.621 136.621-136.621 75.453 0 136.62 61.167 136.62 136.621 0 75.453-61.167 136.62-136.62 136.62Z"/></g><path stroke="url(#a)" stroke-width="2.418" d="M0-1.209h553.581" transform="scale(1 -1) rotate(45 1163.11 91.165)"/><path stroke="url(#b)" stroke-width="2.418" d="M404.846 598.671h391.726"/><path stroke="url(#c)" stroke-width="2.418" d="M599.5 795.742V404.017"/><path stroke="url(#d)" stroke-width="2.418" d="m795.717 796.597-391.441-391.44"/><path fill="#fff" d="M600.709 656.704c-31.384 0-56.825-25.441-56.825-56.824 0-31.384 25.441-56.825 56.825-56.825 31.383 0 56.824 25.441 56.824 56.825 0 31.383-25.441 56.824-56.824 56.824Z"/><g clip-path="url(#e)"><path fill="#666" fill-rule="evenodd" d="M616.426 586.58h-31.434v16.176l3.553-3.554.531-.531h9.068l.074-.074 8.463-8.463h2.565l7.18 7.181V586.58Zm-15.715 14.654 3.698 3.699 1.283 1.282-2.565 2.565-1.282-1.283-5.2-5.199h-6.066l-5.514 5.514-.073.073v2.876a2.418 2.418 0 0 0 2.418 2.418h26.598a2.418 2.418 0 0 0 2.418-2.418v-8.317l-8.463-8.463-7.181 7.181-.071.072Zm-19.347 5.442v4.085a6.045 6.045 0 0 0 6.046 6.045h26.598a6.044 6.044 0 0 0 6.045-6.045v-7.108l1.356-1.355-1.282-1.283-.074-.073v-17.989h-38.689v23.43l-.146.146.146.147Z" clip-rule="evenodd"/></g><path stroke="#C9C9C9" stroke-width="2.418" d="M600.709 656.704c-31.384 0-56.825-25.441-56.825-56.824 0-31.384 25.441-56.825 56.825-56.825 31.383 0 56.824 25.441 56.824 56.825 0 31.383-25.441 56.824-56.824 56.824Z"/></g><defs><linearGradient id="a" x1="554.061" x2="-.48" y1=".083" y2=".087" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="b" x1="796.912" x2="404.507" y1="599.963" y2="599.965" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="c" x1="600.792" x2="600.794" y1="403.677" y2="796.082" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><linearGradient id="d" x1="404.85" x2="796.972" y1="403.903" y2="796.02" gradientUnits="userSpaceOnUse"><stop stop-color="#C9C9C9" stop-opacity="0"/><stop offset=".208" stop-color="#C9C9C9"/><stop offset=".792" stop-color="#C9C9C9"/><stop offset="1" stop-color="#C9C9C9" stop-opacity="0"/></linearGradient><clipPath id="e"><path fill="#fff" d="M581.364 580.535h38.689v38.689h-38.689z"/></clipPath></defs></svg>

================
File: styles/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: Arial, Helvetica, sans-serif;
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
    --sidebar-background: 0 0% 98%;
    --sidebar-foreground: 240 5.3% 26.1%;
    --sidebar-primary: 240 5.9% 10%;
    --sidebar-primary-foreground: 0 0% 98%;
    --sidebar-accent: 240 4.8% 95.9%;
    --sidebar-accent-foreground: 240 5.9% 10%;
    --sidebar-border: 220 13% 91%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
    --sidebar-background: 240 5.9% 10%;
    --sidebar-foreground: 240 4.8% 95.9%;
    --sidebar-primary: 224.3 76.3% 48%;
    --sidebar-primary-foreground: 0 0% 100%;
    --sidebar-accent: 240 3.7% 15.9%;
    --sidebar-accent-foreground: 240 4.8% 95.9%;
    --sidebar-border: 240 3.7% 15.9%;
    --sidebar-ring: 217.2 91.2% 59.8%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    './pages/**/*.{ts,tsx}',
    './components/**/*.{ts,tsx}',
    './app/**/*.{ts,tsx}',
    './src/**/*.{ts,tsx}',
	],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: 0 },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: 0 },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate")],
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "target": "ES6",
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

================
File: v0-user-next.config.js
================
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  experimental: {
    appDir: true,
  },
  webpack: (config, { isServer }) => {
    if (!isServer) {
      config.resolve.fallback = {
        ...config.resolve.fallback,
        fs: false,
      }
    }
    return config
  },
}

module.exports = nextConfig



================================================================
End of Codebase
================================================================
